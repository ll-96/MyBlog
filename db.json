{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/ocean/source/404.html","path":"404.html","modified":1,"renderable":1},{"_id":"themes/ocean/source/L.ico","path":"L.ico","modified":1,"renderable":1},{"_id":"themes/ocean/source/robots.txt","path":"robots.txt","modified":1,"renderable":1},{"_id":"themes/ocean/source/css/404.styl","path":"css/404.styl","modified":1,"renderable":1},{"_id":"themes/ocean/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/ocean/source/fancybox/jquery.fancybox.min.css","path":"fancybox/jquery.fancybox.min.css","modified":1,"renderable":1},{"_id":"themes/ocean/source/fancybox/jquery.fancybox.min.js","path":"fancybox/jquery.fancybox.min.js","modified":1,"renderable":1},{"_id":"themes/ocean/source/images/L.svg","path":"images/L.svg","modified":1,"renderable":1},{"_id":"themes/ocean/source/images/forrestgump.png","path":"images/forrestgump.png","modified":1,"renderable":1},{"_id":"themes/ocean/source/images/logo.svg","path":"images/logo.svg","modified":1,"renderable":1},{"_id":"themes/ocean/source/js/busuanzi-2.3.pure.min.js","path":"js/busuanzi-2.3.pure.min.js","modified":1,"renderable":1},{"_id":"themes/ocean/source/js/copybtn.js","path":"js/copybtn.js","modified":1,"renderable":1},{"_id":"themes/ocean/source/js/jquery-2.0.3.min.js","path":"js/jquery-2.0.3.min.js","modified":1,"renderable":1},{"_id":"themes/ocean/source/js/jquery.justifiedGallery.min.js","path":"js/jquery.justifiedGallery.min.js","modified":1,"renderable":1},{"_id":"themes/ocean/source/js/lazyload.min.js","path":"js/lazyload.min.js","modified":1,"renderable":1},{"_id":"themes/ocean/source/js/ocean.js","path":"js/ocean.js","modified":1,"renderable":1},{"_id":"themes/ocean/source/js/pace.min.js","path":"js/pace.min.js","modified":1,"renderable":1},{"_id":"themes/ocean/source/js/search.js","path":"js/search.js","modified":1,"renderable":1},{"_id":"themes/ocean/source/js/tocbot.min.js","path":"js/tocbot.min.js","modified":1,"renderable":1},{"_id":"themes/ocean/source/css/feathericon/feathericon.eot","path":"css/feathericon/feathericon.eot","modified":1,"renderable":1},{"_id":"themes/ocean/source/css/feathericon/feathericon.svg","path":"css/feathericon/feathericon.svg","modified":1,"renderable":1},{"_id":"themes/ocean/source/css/feathericon/feathericon.ttf","path":"css/feathericon/feathericon.ttf","modified":1,"renderable":1},{"_id":"themes/ocean/source/css/feathericon/feathericon.woff","path":"css/feathericon/feathericon.woff","modified":1,"renderable":1},{"_id":"themes/ocean/source/css/feathericon/feathericon.woff2","path":"css/feathericon/feathericon.woff2","modified":1,"renderable":1},{"_id":"themes/ocean/source/images/ocean/ocean.mp4","path":"images/ocean/ocean.mp4","modified":1,"renderable":1},{"_id":"themes/ocean/source/images/ocean/ocean.ogv","path":"images/ocean/ocean.ogv","modified":1,"renderable":1},{"_id":"themes/ocean/source/images/ocean/ocean.png","path":"images/ocean/ocean.png","modified":1,"renderable":1},{"_id":"themes/ocean/source/images/ocean/ocean.webm","path":"images/ocean/ocean.webm","modified":1,"renderable":1},{"_id":"themes/ocean/source/images/ocean/overlay-hero.png","path":"images/ocean/overlay-hero.png","modified":1,"renderable":1}],"Cache":[{"_id":"source/_posts/MySQL相关总结.md","hash":"b4b347e7587dccd86f25f199fabe56313d79a41c","modified":1612230962714},{"_id":"source/_posts/hello-world.md","hash":"3f050d79dbfeaa9b916f483a8c6d7c232ca8dbec","modified":1612230962530},{"_id":"source/_posts/文件操作.md","hash":"fdc2a61cb1027d59589cda5024f6d01de2a50925","modified":1612230962878},{"_id":"themes/ocean/LICENSE","hash":"7df059597099bb7dcf25d2a9aedfaf4465f72d8d","modified":1612233711626},{"_id":"themes/ocean/README.md","hash":"28876fb36a83896ba0d54923b2ef17c2f9f183bf","modified":1612233711626},{"_id":"themes/ocean/_config.yml","hash":"7e0887ebf4b136f334d2d4a61c2a98d1c7a1af3f","modified":1612237034253},{"_id":"themes/ocean/package.json","hash":"b993176f8c35bc3ab9dbd8642ec6cd125fcb447e","modified":1612233711626},{"_id":"themes/ocean/languages/de.yml","hash":"3ebf0775abbee928c8d7bda943c191d166ded0d3","modified":1612233711626},{"_id":"themes/ocean/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1612233711626},{"_id":"themes/ocean/languages/es.yml","hash":"76edb1171b86532ef12cfd15f5f2c1ac3949f061","modified":1612233711626},{"_id":"themes/ocean/languages/fr.yml","hash":"415e1c580ced8e4ce20b3b0aeedc3610341c76fb","modified":1612233711626},{"_id":"themes/ocean/languages/ja.yml","hash":"a73e1b9c80fd6e930e2628b393bfe3fb716a21a9","modified":1612233711626},{"_id":"themes/ocean/languages/ko.yml","hash":"881d6a0a101706e0452af81c580218e0bfddd9cf","modified":1612233711626},{"_id":"themes/ocean/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1612233711626},{"_id":"themes/ocean/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1612233711626},{"_id":"themes/ocean/languages/pt.yml","hash":"57d07b75d434fbfc33b0ddb543021cb5f53318a8","modified":1612233711626},{"_id":"themes/ocean/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1612233711626},{"_id":"themes/ocean/languages/zh-CN.yml","hash":"0d2244f95623305744eb40dcec7ace32a0223461","modified":1612233711626},{"_id":"themes/ocean/languages/zh-TW.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1612233711626},{"_id":"themes/ocean/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1612233711626},{"_id":"themes/ocean/layout/categories.ejs","hash":"bf3eff3f238a9798227ce868f5c08b230f66ea04","modified":1612233711626},{"_id":"themes/ocean/layout/index.ejs","hash":"f8dbff295abb2a87bec1fb5f5feec2e408743693","modified":1612233711626},{"_id":"themes/ocean/layout/layout.ejs","hash":"a0648569b4e28464559ad8efae9115d35e30fd28","modified":1612233711626},{"_id":"themes/ocean/layout/page.ejs","hash":"a9a48ae63f5d68a36382951166fdd6e482b901f1","modified":1612233711626},{"_id":"themes/ocean/layout/post.ejs","hash":"a9a48ae63f5d68a36382951166fdd6e482b901f1","modified":1612233711626},{"_id":"themes/ocean/layout/tags.ejs","hash":"05a9c7ddfb7163d2dabdf5cbd9add1a2e43ec203","modified":1612233711626},{"_id":"themes/ocean/source/404.html","hash":"788929fab7b99dd74575399f41cddae6f63ce1f4","modified":1612233711630},{"_id":"themes/ocean/source/L.ico","hash":"189dcfe706c3f795f8c1d581d62cdb41cec54034","modified":1612233909517},{"_id":"themes/ocean/source/robots.txt","hash":"066f2545f69113adbdac1b2fbc5fab43e9ba571e","modified":1612233711662},{"_id":"themes/ocean/layout/_partial/after-footer.ejs","hash":"7127f4d8327f9836c128d998a36a28082038b9ef","modified":1612233711626},{"_id":"themes/ocean/layout/_partial/archive-post.ejs","hash":"8f01ad49dec1688829ebe5e5b3c2dda4264bd5e4","modified":1612233711626},{"_id":"themes/ocean/layout/_partial/archive.ejs","hash":"c3bb015d3f368cf63ba51779ba849dd263654f23","modified":1612233711626},{"_id":"themes/ocean/layout/_partial/article.ejs","hash":"e16d31f1d94c603cca33fb2527f082d2987e878e","modified":1612233711626},{"_id":"themes/ocean/layout/_partial/footer.ejs","hash":"8f45c8f501bf1d28ff5b101940191fd9c1aa374a","modified":1612233711626},{"_id":"themes/ocean/layout/_partial/head.ejs","hash":"1bdcdfa202b82ff276b775dcadde06817e3c964b","modified":1612233711626},{"_id":"themes/ocean/layout/_partial/ocean.ejs","hash":"f8cc4e4f9df1832b8ab6d7033840c57f3ad14fad","modified":1612233711626},{"_id":"themes/ocean/layout/_partial/sidebar.ejs","hash":"e7e40dba2eadf0c2d2a5c75c58c6f78234a039a4","modified":1612233711626},{"_id":"themes/ocean/layout/_partial/totop.ejs","hash":"72b960315983ee95363fa9cabe82f52916ac9ae3","modified":1612233711626},{"_id":"themes/ocean/source/css/404.styl","hash":"14b2fec2da86081f0545732552aa5f07b545c19a","modified":1612233711630},{"_id":"themes/ocean/source/css/_extend.styl","hash":"deb6aca91c40516f5d638008a72f9def42e5d081","modified":1612233711630},{"_id":"themes/ocean/source/css/_feathericon.styl","hash":"8494f0e869411781264868f08eda62fd838e0cee","modified":1612233711630},{"_id":"themes/ocean/source/css/_mixins.styl","hash":"6959409df2dd0a1ca05be0c0e9b2a884efdfb82d","modified":1612233711630},{"_id":"themes/ocean/source/css/_normalize.styl","hash":"b3337320133b7a336db7033aa6bbe94b054c0b21","modified":1612233711630},{"_id":"themes/ocean/source/css/_variables.styl","hash":"68470eee12d812fcc51c1bd7a4578acae4613fa0","modified":1612233711630},{"_id":"themes/ocean/source/css/style.styl","hash":"f6fe68d30aea9155d405f0f5e3c43e4845d9d8b2","modified":1612233711630},{"_id":"themes/ocean/source/fancybox/jquery.fancybox.min.css","hash":"2e6a66987dbc7a57bbfd2655bce166739b4ba426","modified":1612233711630},{"_id":"themes/ocean/source/images/L.svg","hash":"8076282543f5f1dafb5ea63d42acebad62b98abd","modified":1612233924129},{"_id":"themes/ocean/source/images/logo.svg","hash":"c928f7fd9d7addcaeb930b3be428bdd72b3fa5bc","modified":1612233983246},{"_id":"themes/ocean/source/js/busuanzi-2.3.pure.min.js","hash":"6e41f31100ae7eb3a6f23f2c168f6dd56e7f7a9a","modified":1612233711662},{"_id":"themes/ocean/source/js/copybtn.js","hash":"53dbe22b5e58c33a91d6ecee9bed0a1b94a3ca31","modified":1612233711662},{"_id":"themes/ocean/source/js/jquery.justifiedGallery.min.js","hash":"73b9373cd80bdbf77e711818095f3f120a019547","modified":1612233711662},{"_id":"themes/ocean/source/js/lazyload.min.js","hash":"b801b3946fb9b72e03512c0663458e140e1fa77b","modified":1612233711662},{"_id":"themes/ocean/source/js/ocean.js","hash":"acac20176cf22a84f889894d7482dc9207076f12","modified":1612233711662},{"_id":"themes/ocean/source/js/pace.min.js","hash":"d32ab818e0f97d3b0c80f5631fc23d8a0cb52795","modified":1612233711662},{"_id":"themes/ocean/source/js/search.js","hash":"3e66ea259eff66e36e240b695c4753c5d4454bbb","modified":1612233711662},{"_id":"themes/ocean/source/js/tocbot.min.js","hash":"bae97e8a24a05a99335f8e725641c8ca9c50502a","modified":1612233711662},{"_id":"themes/ocean/layout/_partial/post/albums.ejs","hash":"a7b0c7059ec6ce0c0d4fabdece662e0ebe5f85b9","modified":1612233711626},{"_id":"themes/ocean/layout/_partial/post/busuanzi.ejs","hash":"8db57f869ba5810a83e47395e51df50f59a6bcb2","modified":1612233711626},{"_id":"themes/ocean/layout/_partial/post/category.ejs","hash":"386f47b0299351f45cac2ad43779893b31f60c28","modified":1612233711626},{"_id":"themes/ocean/layout/_partial/post/date.ejs","hash":"6197802873157656e3077c5099a7dda3d3b01c29","modified":1612233711626},{"_id":"themes/ocean/layout/_partial/post/gallery.ejs","hash":"ff0279081ba55c1fbe6d7029cc15f197b0c503fd","modified":1612233711626},{"_id":"themes/ocean/layout/_partial/post/gitalk.ejs","hash":"1bbb92e9c571de1f539120ad5519b91c8a02c709","modified":1612233711626},{"_id":"themes/ocean/layout/_partial/post/justifiedGallery.ejs","hash":"c6fcc0f5b340e40504ff4ff5c0487e66b57b3ed0","modified":1612233711626},{"_id":"themes/ocean/layout/_partial/post/nav.ejs","hash":"c997e2f8f93a13f8684b46dcef1bbb052349d1c7","modified":1612233711626},{"_id":"themes/ocean/layout/_partial/post/search.ejs","hash":"2c9d19d1685e834aa2020998da2a2d259ce9b9ff","modified":1612233711626},{"_id":"themes/ocean/layout/_partial/post/tag.ejs","hash":"adaea79d14202c281d457a2cb4ee766d023c4088","modified":1612233711626},{"_id":"themes/ocean/layout/_partial/post/title.ejs","hash":"fb72872142ee3a9e68f763d2c5d49b601aa0e6ad","modified":1612233711626},{"_id":"themes/ocean/layout/_partial/post/tocbot.ejs","hash":"11ddd6106103c3b4506f69da8b6d4b8f20c95c89","modified":1612233711626},{"_id":"themes/ocean/layout/_partial/post/topping.ejs","hash":"7a839e91c502cf4c188b8c10f4f02675dbc5cde5","modified":1612233711626},{"_id":"themes/ocean/layout/_partial/post/valine.ejs","hash":"cde2408a3e1615d1899e6e89e8d2ccbecef1d7d7","modified":1612233711626},{"_id":"themes/ocean/source/css/_partial/albums.styl","hash":"0659d5f7469f24a415354ff767d949926465d515","modified":1612233711630},{"_id":"themes/ocean/source/css/_partial/apple.styl","hash":"e06dce604cc58ec39d677e4e59910c2725684901","modified":1612233711630},{"_id":"themes/ocean/source/css/_partial/archive.styl","hash":"8aefdcf2d542ad839018c2c58511e3318a38490d","modified":1612233711630},{"_id":"themes/ocean/source/css/_partial/article.styl","hash":"89be74d7c23366cad7ae1acf0db38bf0e7687a46","modified":1612233711630},{"_id":"themes/ocean/source/css/_partial/articles.styl","hash":"7bf289013d304505984b251be725b49165a694fd","modified":1612233711630},{"_id":"themes/ocean/source/css/_partial/categories.styl","hash":"f0c898823a5ddc37ae6bf76cc34ce8e50dd30885","modified":1612233711630},{"_id":"themes/ocean/source/css/_partial/float.styl","hash":"d888df89a172e4c8119cb8740fc1eae1a9539157","modified":1612233711630},{"_id":"themes/ocean/source/css/_partial/footer.styl","hash":"24779cbce1012d4f35ffc6b3ec0830cbc2ea3b3f","modified":1612233711630},{"_id":"themes/ocean/source/css/_partial/gallery.styl","hash":"7bdc2c9fb4971dbd7511c5cbb69bd611f20db591","modified":1612233711630},{"_id":"themes/ocean/source/css/_partial/gitalk.styl","hash":"3706eef2e0541493f1679a30241d279e29dfdc17","modified":1612233711630},{"_id":"themes/ocean/source/css/_partial/highlight.styl","hash":"c6e99fd23056fb01177aeefbc5dd4a8e88cf8f81","modified":1612233711630},{"_id":"themes/ocean/source/css/_partial/justifiedGallery.styl","hash":"e7b5784ffd501f98216a717f876f2adb23fa5cd9","modified":1612233711630},{"_id":"themes/ocean/source/css/_partial/layou.styl","hash":"f9aa5b28bc4e38d5f6e975b5b9f4dd24addea232","modified":1612233711630},{"_id":"themes/ocean/source/css/_partial/lists.styl","hash":"6fd213c53027d42164bfc9f0e3b4ea02317bfb89","modified":1612233711630},{"_id":"themes/ocean/source/css/_partial/mobile.styl","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1612233711630},{"_id":"themes/ocean/source/css/_partial/navbar.styl","hash":"5c7b589b412720fb93c9d9e25f031d8207cdef24","modified":1612233711630},{"_id":"themes/ocean/source/css/_partial/ocean.styl","hash":"69ba351909c73eb1e04510facc9b35dd584198e0","modified":1612233711630},{"_id":"themes/ocean/source/css/_partial/pace.styl","hash":"e326918ba276ee332d0598d8193ccd8353e7d916","modified":1612233711630},{"_id":"themes/ocean/source/css/_partial/search.styl","hash":"011aaf21942dfff514ed4e98ce20142efbdd1b71","modified":1612233711630},{"_id":"themes/ocean/source/css/_partial/sidebar.styl","hash":"600c70f1de82da5223af290d47a583f9c379d188","modified":1612233711630},{"_id":"themes/ocean/source/css/_partial/tag.styl","hash":"925af8beede44ab53fe3cd0a5c472d2baa03baec","modified":1612233711630},{"_id":"themes/ocean/source/css/_partial/tocbot.styl","hash":"da8560a8f9718d3afb9760956f9f8e4bb88b3dd8","modified":1612233711630},{"_id":"themes/ocean/source/css/_partial/totop.styl","hash":"4bae031b6852384666cdf36e98c6bbbba1281453","modified":1612233711630},{"_id":"themes/ocean/source/css/_partial/valine.styl","hash":"b980d02c0d1aad4866c8173c20f5e6b53026cbd5","modified":1612233711630},{"_id":"themes/ocean/source/css/feathericon/feathericon.eot","hash":"e2a01ae6f849841bc7a9fd21e5b7b450f1ded19b","modified":1612233711630},{"_id":"themes/ocean/source/css/feathericon/feathericon.ttf","hash":"d0d80c3c960d7d45e6bd7fa428d8a6a8c8245b2d","modified":1612233711630},{"_id":"themes/ocean/source/css/feathericon/feathericon.woff","hash":"d22fe861e47afd92969ab46c7cbb7ea9c225aaf8","modified":1612233711630},{"_id":"themes/ocean/source/css/feathericon/feathericon.woff2","hash":"2c11c45331d914ee38ad42ccf966132a508b5596","modified":1612233711630},{"_id":"themes/ocean/source/images/ocean/overlay-hero.png","hash":"92481a1848c35be96a693af11f77265323a7c189","modified":1612233711662},{"_id":"themes/ocean/source/fancybox/jquery.fancybox.min.js","hash":"600c86071c2b5198cfa2c052dd90b78920f62b45","modified":1612233711630},{"_id":"themes/ocean/source/js/jquery-2.0.3.min.js","hash":"ab131f0b13a89f24543fadbf496b1c813d417c02","modified":1612233711662},{"_id":"themes/ocean/source/css/feathericon/feathericon.svg","hash":"c113006c6822451802c8457128c352c0e4934453","modified":1612233711630},{"_id":"themes/ocean/screenshots/hexo-theme-ocean.jpg","hash":"13b5045d2120cac2f68849757f5e0af08938b7c6","modified":1612233711630},{"_id":"themes/ocean/source/images/forrestgump.png","hash":"18ad6a8ba815878e36a0d5562136dc4fb8920c12","modified":1612233711634},{"_id":"themes/ocean/source/images/ocean/ocean.ogv","hash":"9c6b5d6b0544472cee39f5eafac2d5cbba5fd86b","modified":1612233711646},{"_id":"themes/ocean/source/images/ocean/ocean.png","hash":"8245d07f812625d19b48ad2d00f8191f2aa4d304","modified":1612233711650},{"_id":"themes/ocean/source/images/ocean/ocean.webm","hash":"65aa2b6483e0151611899e31571057334c60d9e4","modified":1612233711662},{"_id":"themes/ocean/source/images/ocean/ocean.mp4","hash":"1e89cac2d652005d9dafd3ecb4dd460a8ff6d6af","modified":1612233711642},{"_id":"public/atom.xml","hash":"402dc05664c49124574b51753dfde4c5df40e674","modified":1612238474888},{"_id":"public/search.xml","hash":"f2d044b48827ba2bbd1e99b03f4a31abf2ad4eeb","modified":1612238474888},{"_id":"public/2021/02/02/hello-world/index.html","hash":"985d724fd24b6f1db134bf349a4174804007603f","modified":1612238474888},{"_id":"public/archives/index.html","hash":"f50ffe4c238b63a0d13da60c331ae77cf8fff66b","modified":1612238474888},{"_id":"public/archives/2020/index.html","hash":"67695fb42b916dbb2fcc1899a249e109d6fce4bc","modified":1612238474888},{"_id":"public/archives/2020/07/index.html","hash":"33cc7ee095cd263a01880f4b1e6629dd1a75c41e","modified":1612238474888},{"_id":"public/archives/2020/08/index.html","hash":"0d7657c5ce23b1e041c6bd5c3d6dc0c46f74cd8e","modified":1612238474888},{"_id":"public/archives/2021/index.html","hash":"4b1d9d8f167fc34015f20db22fd02b38338cf5cc","modified":1612238474888},{"_id":"public/archives/2021/02/index.html","hash":"cc27e11d85be548b924014b1f3d0a992d3357be2","modified":1612238474888},{"_id":"public/index.html","hash":"c9b4ca6e17e84c178c1abce3e86a5beb3a3ebb21","modified":1612238474888},{"_id":"public/tags/MySQL/index.html","hash":"415de0ad805423853ac159fdcf970872b673fec4","modified":1612238474888},{"_id":"public/2020/08/01/文件操作/index.html","hash":"484a812a962e98944d3205181e138e60920f0a23","modified":1612238474888},{"_id":"public/2020/07/14/MySQL相关总结/index.html","hash":"01af270221ce46e66647cbe568b859a335f3f708","modified":1612238474888},{"_id":"public/L.ico","hash":"189dcfe706c3f795f8c1d581d62cdb41cec54034","modified":1612238474888},{"_id":"public/robots.txt","hash":"066f2545f69113adbdac1b2fbc5fab43e9ba571e","modified":1612238474888},{"_id":"public/images/L.svg","hash":"8076282543f5f1dafb5ea63d42acebad62b98abd","modified":1612238474888},{"_id":"public/images/logo.svg","hash":"c928f7fd9d7addcaeb930b3be428bdd72b3fa5bc","modified":1612238474888},{"_id":"public/css/feathericon/feathericon.eot","hash":"e2a01ae6f849841bc7a9fd21e5b7b450f1ded19b","modified":1612238474888},{"_id":"public/css/feathericon/feathericon.ttf","hash":"d0d80c3c960d7d45e6bd7fa428d8a6a8c8245b2d","modified":1612238474888},{"_id":"public/css/feathericon/feathericon.woff","hash":"d22fe861e47afd92969ab46c7cbb7ea9c225aaf8","modified":1612238474888},{"_id":"public/css/feathericon/feathericon.woff2","hash":"2c11c45331d914ee38ad42ccf966132a508b5596","modified":1612238474888},{"_id":"public/images/ocean/overlay-hero.png","hash":"92481a1848c35be96a693af11f77265323a7c189","modified":1612238474888},{"_id":"public/css/feathericon/feathericon.svg","hash":"c113006c6822451802c8457128c352c0e4934453","modified":1612238474888},{"_id":"public/404.html","hash":"788929fab7b99dd74575399f41cddae6f63ce1f4","modified":1612238474888},{"_id":"public/css/404.css","hash":"952f9d1b869886a2940768fb7d1fd891ccea29fa","modified":1612238474888},{"_id":"public/fancybox/jquery.fancybox.min.css","hash":"2e6a66987dbc7a57bbfd2655bce166739b4ba426","modified":1612238474888},{"_id":"public/js/busuanzi-2.3.pure.min.js","hash":"6e41f31100ae7eb3a6f23f2c168f6dd56e7f7a9a","modified":1612238474888},{"_id":"public/js/copybtn.js","hash":"53dbe22b5e58c33a91d6ecee9bed0a1b94a3ca31","modified":1612238474888},{"_id":"public/js/lazyload.min.js","hash":"b801b3946fb9b72e03512c0663458e140e1fa77b","modified":1612238474888},{"_id":"public/js/ocean.js","hash":"acac20176cf22a84f889894d7482dc9207076f12","modified":1612238474888},{"_id":"public/js/pace.min.js","hash":"d32ab818e0f97d3b0c80f5631fc23d8a0cb52795","modified":1612238474888},{"_id":"public/js/search.js","hash":"3e66ea259eff66e36e240b695c4753c5d4454bbb","modified":1612238474888},{"_id":"public/js/tocbot.min.js","hash":"bae97e8a24a05a99335f8e725641c8ca9c50502a","modified":1612238474888},{"_id":"public/css/style.css","hash":"1fec8842043830961ca5af719efea579576ea996","modified":1612238474888},{"_id":"public/js/jquery.justifiedGallery.min.js","hash":"73b9373cd80bdbf77e711818095f3f120a019547","modified":1612238474888},{"_id":"public/images/forrestgump.png","hash":"18ad6a8ba815878e36a0d5562136dc4fb8920c12","modified":1612238474888},{"_id":"public/fancybox/jquery.fancybox.min.js","hash":"600c86071c2b5198cfa2c052dd90b78920f62b45","modified":1612238474888},{"_id":"public/js/jquery-2.0.3.min.js","hash":"ab131f0b13a89f24543fadbf496b1c813d417c02","modified":1612238474888},{"_id":"public/images/ocean/ocean.ogv","hash":"9c6b5d6b0544472cee39f5eafac2d5cbba5fd86b","modified":1612238474888},{"_id":"public/images/ocean/ocean.png","hash":"8245d07f812625d19b48ad2d00f8191f2aa4d304","modified":1612238474888},{"_id":"public/images/ocean/ocean.webm","hash":"65aa2b6483e0151611899e31571057334c60d9e4","modified":1612238474888},{"_id":"public/images/ocean/ocean.mp4","hash":"1e89cac2d652005d9dafd3ecb4dd460a8ff6d6af","modified":1612238474888}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"MySQL相关总结","date":"2020-07-14T03:52:37.000Z","type":"MySQL","_content":"\n# MySQL 数据库\n\nMySQL 是最流行的关系型数据库管理系统，在 WEB 应用方面 MySQL 是最好的 RDBMS(Relational Database Management System：关系数据库管理系统)应用软件之一。\n\n<!--more-->\n\n# MySQL存储引擎\n\n## 查看当前存储引擎\n\n```sql\nshow variables like '%storage_engine';\nshow engines;\n```\n\n## MySQL常用引擎\n\n1. InnoDB\n\n   事务型数据库的首选引擎，支持事务安全表（ACID），支持行锁定和外键，InnoDB是默认的MySQL引擎。\n\n   InnoDB主要特性有：\n\n   1. InnoDB 给 MySQL 提供了具有提交、回滚、崩溃恢复能力的事务安全存储引擎。\n   2. InnoDB 是为处理巨大数据量的最大性能设计。它的 CPU 效率比其他基于磁盘的关系型数据库引擎高。\n   3. InnoDB 存储引擎自带缓冲池，可以将数据和索引缓存在内存中。\n   4. InnoDB 支持外键完整性约束。\n   5. InnoDB 被用在众多需要高性能的大型数据库站点上\n   6. InnoDB 支持行级锁\n\n2. MyISAM\n\n   MyISAM 基于 ISAM 存储引擎，并对其进行扩展。它是在Web、数据仓储和其他应用环境下最常使用的存储引擎之一。MyISAM 拥有较高的插入、查询速度，但不支持事物。\n\n   MyISAM主要特性有：\n\n   1. 大文件支持更好\n   2. 当删除、更新、插入混用时，产生更少碎片。\n   3. 每个 MyISAM 表最大索引数是64，这可以通过重新编译来改变。每个索引最大的列数是16\n   4. 最大的键长度是1000字节。\n   5. BLOB和TEXT列可以被索引\n   6. NULL 被允许在索引的列中，这个值占每个键的0~1个字节\n   7. 所有数字键值以高字节优先被存储以允许一个更高的索引压缩\n   8. MyISAM 类型表的 AUTO_INCREMENT 列更新比 InnoDB 类型的 AUTO_INCREMENT 更快\n   9. 可以把数据文件和索引文件放在不同目录\n   10. 每个字符列可以有不同的字符集\n   11. 有 VARCHAR 的表可以固定或动态记录长度\n   12. VARCHAR 和 CHAR 列可以多达 64KB\n   13. 只支持表锁\n\n3. MEMORY\n\n   MEMORY 存储引擎将表中的数据存储到内存中，为查询和引用其他表数据提供快速访问。\n\n## 存储引擎的选择\n\n一般来说，对插入和并发性能要求较高的，或者需要外键，或者需要事务支持的情况下，需要选择 InnoDB，\n\n插入较少，查询较多的场景，优先考虑 MyISAM。\n\n### 使用引擎\n\n一般在建表时添加\n\n```\ncreate table abc (\n    name char(10)\n) engine=MyISAM charset=utf8;\n\ncreate table xyz (\n    name char(10)\n) engine=InnoDB charset=utf8;\n```\n\n### InnoDB 和 MyISAM 在文件方面的区别\n\n1. InnoDB 将一张表存储为两个文件\n\n   - demo.frm -> 存储表的结构和索引\n   - demo.ibd -> 存储数据，ibd 存储是有限的, 存储不足自动创建 ibd1, ibd2\n   - InnoDB 的文件创建在对应的数据库中, 不能任意的移动\n\n2. MyISAM 将一张表存储为三个文件\n\n   - demo.frm -> 存储表的结构\n\n   - demo.myd -> 存储数据\n\n   - demo.myi -> 存储表的索引\n\n   - MyISAM 的文件可以任意的移动\n\n     \n\n# MySQL索引\n\n## 索引介绍\n\n### 索引是什么\n\n- 索引是帮助MySQL**高效获取数据的数据结构**，能**加快数据库检索速度**、**排序**等，类似于一本书的目录。\n\n- 索引本身往往是存储在磁盘上的文件中的（单独的索引文件或者是和数据库一起存储在数据文件中（InnoDB））\n- 包括**聚集索引、覆盖索引、组合索引、前缀索引、唯一索引等**，一般默认使用的都是**B+树结构**的索引\n\n### 索引的优势和劣势\n\n**优势：**\n\n- 可以**提高数据检索的效率**，降低数据库的IO成本；\n- 可以通过索引**对数据进行排序**，降低数据排序的成本，减少CPU消耗；\n  - 被索引的列会自动排序，包括**单列索引**和**组合索引**；\n  - 按照索引列的顺序进行order by **排序效率会提高**很多；\n  - where 索引列 在存储引擎层处理；\n\n**劣势：**\n\n- 会**占用内存空间**；\n- 虽然会提高搜索效率，但是会**降低更新表的效率**，因为每次修改不光要修改表数据，还要修改对应的索引文件；\n\n## 索引的分类\n\n### 单列索引\n\n- 普通索引：MySQL中最基本的索引，没有什么限制，允许在定义索引的列中插入重复值的空值，纯粹是为了查询更快；(**add index**)\n- 唯一索引：索引中的值必须是唯一的，但是允许为空值；(**add unique index**)\n- 主键索引：特殊的唯一索引，不允许为空值。pk\n\n### 组合索引\n\n- 多个字段组合上创建的索引；(**add index(col1, col2,...)**)\n- 需要遵循**最左前缀原则（最左匹配原则）**\n- 一般**建议使用组合索引代替单列索引（主键除外）**\n\n### 全文索引\n\n只有在MyISAM、InnoDB（5.6以后）上才能使用，而且只能在CHAR、VARCHAR、TEXT类型字段上使用全文索引。\n\n优先级最高，最先执行，不会执行其他索引\n\n### 空间索引\n\n\n\n## 索引的使用\n\n### 创建索引\n\n- 单列索引——普通索引\n\n  ```python\n  CREATE INDEX index_name ON table_name (column_name);\n  ALTER TABLE table_name ADD INDEX index_name (column_name);\n  ```\n\n- 单列索引——唯一索引\n\n  ```python\n  CREATE UNIQUE INDEX index_name ON table_name (column_name);\n  ALTER TABLE table_name ADD UNIQUE INDEX index_name(column_name);\n  ```\n\n- 单列索引——全文索引\n\n  ```python\n  CREATE UNIQUE FULLTEXT INDEX fulltext_index_name ON table_name (column_name)\n  ```\n\n- 组合索引\n\n  ```python\n  CREATE INDEX index_name ON table_name (column_name_1, column_name_2);\n  ```\n\n  \n\n### 删除索引\n\n```python\nDROP INDEX index_name ON table_name;\n```\n\n### 查看索引\n\n```python \nSHOW INDEX FROM table_name;\n```\n\n\n\n## 索引原理分析\n\n### 索引的存储结构\n\n- 索引是在**存储引擎中实现**的，也就是说使用不同的存储引擎，会使用不同的索引；\n- **MyISAM** 和 **InnoDB** 存储引擎：**只支持 B+TREE 索引**，**默认使用BTREE**，不能更换；\n- MEMORY/HEAP 存储引擎：支持HASH和BTREE索引；\n  (HASH索引比BTREE快，所以MEMORY引擎也更快)\n\n### B树 和 B+树\n\n数据结构演示网址：https://www.cs.usfca.edu/~galles/visualization/Algorithms.html\n\n#### B树\n\n- 定义：\n\n  \n\n#### B+树\n\n- 定义：\n\n  \n\n# MySQL 事务\n\n## 一、事务\n\n- 事务主要处理操作量大、复杂度高、并且关联性强的数据。\n\n- 进行一系列相互关联的操作：删除用户—>删除该用户相关所有的表数据。\n\n- 在MySQL中只有InnoDB存储引擎支持事务。\n- 事务处理可以用来维护数据库的数据完整性，保证成批的SQL语句要么不执行，要么都执行成功。\n\n## 二、事物的四大特性\n\n在写入或更新数据的过程中，为保证事务的正确可靠，必需具备四个特性（ACID）：\n\n1. **原子性**（Atomicity）\n\n   - 事务中的所有操作，要么全部完成，要么全部不执行，不会结束在中间某个环节；\n   - 事务在执行过程中发生错误，会被**回滚（Rollback）**到事务开始时前的状态，执行完成会有提交操作；\n\n2. **一致性**（Consistency）\n\n   ​\t\t事务开始前和事务结束后，数据库的完整性不能被破坏，写入的数据完全符合数据库的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。\n\n3. **隔离性**（Isolation）\n\n   ​\t\t事务并发会相互影响，多个事务同时操作同一个数据时可能会出现的问题：\n\n   - **脏读**：事务A修改了一个数据，但未提交，**事务B读到了事务A未提交的更新结果**，如果事务A提交失败，事务B读到的就是脏数据。\n   - **不可重复读**：在同一个事务中，对于同一个数据读取的结果不一致。比如，**事务B在事务A提交前后读取到的内容不一致**，导致的原因就是并发修改记录。想要避免这种情况，就要**对修改的记录进行加锁**，但这会导致锁竞争加剧，影响性能。另一种方式是通过**MVCC（多版本的并发控制）**可以在无锁的情况下避免不可重复读。\n   - **幻读**：在同一个事务中，同一个查询多次返回的结果不一致。事务A新增了一条记录，事务B在事务A提交前后各执行了一次查询操作，发现后一次比前一次多了一条记录。幻读是由于并发事务增加记录导致的，这个不能像不可重复读通过记录加锁解决，因为对于新增的记录根本无法加锁。需要将事务串行化，才能避免幻读。\n\n   事务的隔离级别从低到高：\n\n   1. **读取未提交 (Read uncommitted)**\n      - 所有事物都可以看到其他未提交事务的执行结果\n      - 性能不好\n      - 会引发**脏读**：读取到未提交的数据\n   2. **读提交 (read committed)**\n      - 大多数数据库的默认隔离级别（MySQL除外）\n      - 满足了隔离：只能看见已提交事务的改变\n      - 会引发**不可重复读**：事务执行过程中数据可能会被其他事务修改并提交\n   3. **可重复读 (repeatable read)**\n      - **MySQL的默认隔离级别**\n      - 同一事务的多个实例在并发读取数据时，会看到同样的数据行\n      - 会引发**幻读**：多事务同时操作会导致多次读取不一致\n      - InnoDB 通过多版本并发控制 (MVCC，Multiversion Concurrency Control) 机制解决幻读问题；\n      - InnoDB 还通过间隙锁解决幻读问题\n   4. **串行化 (Serializable)**\n      - 这是最高的隔离级别\n      - 它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之,它是在每个读的数据行上加上共享锁。MySQL锁总结\n      - 在这个级别，可能导致大量的超时现象和锁竞争\n\n4. **持久性**（Durability）\n\n   事务处理结束后, 对数据的修改就是永久的, 即便系统故障也不会丢失。\n\n## 三、语法和使用\n\n- 开启事务: `BEGIN`或`START TRANSACTION`\n\n- 提交事务: `COMMIT`, 提交会让所有修改生效\n\n- 回滚: `ROLLBACK`, 撤销正在进行的所有未提交的修改\n\n- 创建保存点: `SAVEPOINT identifier`\n\n- 删除保存点: `RELEASE SAVEPOINT identifier`\n\n- 把事务回滚到保存点: `ROLLBACK TO identifier`\n\n- 查询事务的隔离级别: `show variables like '%isolation%';`\n\n- 设置事务的隔离级别: `SET [SESSION | GLOBAL] TRANSACTION ISOLATION LEVEL {READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE}`\n\n  InnoDB 提供的隔离级别有\n\n  - `READ UNCOMMITTED`\n\n  - `READ COMMITTED`\n\n  - `REPEATABLE READ`\n\n  - `SERIALIZABLE`\n\n    \n\n### 示例：\n\n```sql\ncreate table `abc` (\n    id int unsigned primary key auto_increment,\n    name varchar(32) unique,\n    age int unsigned\n) charset=utf8;\n\nbegin;\ninsert into abc (name, age) values ('aa', 11);\ninsert into abc (name, age) values ('bb', 22);\n-- 在事务中查看一下数据\n-- 同时另开一个窗口，连接到 MySQL 查看一下数据是否一样\nselect * from abc;\ncommit;\n\nbegin;\ninsert into abc (name, age) values ('cc', 33);\ninsert into abc (name, age) values ('dd', 44);\nupdate abc set age=77 where name='aa';\n-- 在事务中查看一下数据\nselect * from abc;\nrollback;\n\nselect * from abc;  -- 事务结束后在查看一下数据\n```\n","source":"_posts/MySQL相关总结.md","raw":"---\ntitle: MySQL相关总结\ndate: 2020-07-14 11:52:37\ntype: MySQL\ntags: MySQL\n---\n\n# MySQL 数据库\n\nMySQL 是最流行的关系型数据库管理系统，在 WEB 应用方面 MySQL 是最好的 RDBMS(Relational Database Management System：关系数据库管理系统)应用软件之一。\n\n<!--more-->\n\n# MySQL存储引擎\n\n## 查看当前存储引擎\n\n```sql\nshow variables like '%storage_engine';\nshow engines;\n```\n\n## MySQL常用引擎\n\n1. InnoDB\n\n   事务型数据库的首选引擎，支持事务安全表（ACID），支持行锁定和外键，InnoDB是默认的MySQL引擎。\n\n   InnoDB主要特性有：\n\n   1. InnoDB 给 MySQL 提供了具有提交、回滚、崩溃恢复能力的事务安全存储引擎。\n   2. InnoDB 是为处理巨大数据量的最大性能设计。它的 CPU 效率比其他基于磁盘的关系型数据库引擎高。\n   3. InnoDB 存储引擎自带缓冲池，可以将数据和索引缓存在内存中。\n   4. InnoDB 支持外键完整性约束。\n   5. InnoDB 被用在众多需要高性能的大型数据库站点上\n   6. InnoDB 支持行级锁\n\n2. MyISAM\n\n   MyISAM 基于 ISAM 存储引擎，并对其进行扩展。它是在Web、数据仓储和其他应用环境下最常使用的存储引擎之一。MyISAM 拥有较高的插入、查询速度，但不支持事物。\n\n   MyISAM主要特性有：\n\n   1. 大文件支持更好\n   2. 当删除、更新、插入混用时，产生更少碎片。\n   3. 每个 MyISAM 表最大索引数是64，这可以通过重新编译来改变。每个索引最大的列数是16\n   4. 最大的键长度是1000字节。\n   5. BLOB和TEXT列可以被索引\n   6. NULL 被允许在索引的列中，这个值占每个键的0~1个字节\n   7. 所有数字键值以高字节优先被存储以允许一个更高的索引压缩\n   8. MyISAM 类型表的 AUTO_INCREMENT 列更新比 InnoDB 类型的 AUTO_INCREMENT 更快\n   9. 可以把数据文件和索引文件放在不同目录\n   10. 每个字符列可以有不同的字符集\n   11. 有 VARCHAR 的表可以固定或动态记录长度\n   12. VARCHAR 和 CHAR 列可以多达 64KB\n   13. 只支持表锁\n\n3. MEMORY\n\n   MEMORY 存储引擎将表中的数据存储到内存中，为查询和引用其他表数据提供快速访问。\n\n## 存储引擎的选择\n\n一般来说，对插入和并发性能要求较高的，或者需要外键，或者需要事务支持的情况下，需要选择 InnoDB，\n\n插入较少，查询较多的场景，优先考虑 MyISAM。\n\n### 使用引擎\n\n一般在建表时添加\n\n```\ncreate table abc (\n    name char(10)\n) engine=MyISAM charset=utf8;\n\ncreate table xyz (\n    name char(10)\n) engine=InnoDB charset=utf8;\n```\n\n### InnoDB 和 MyISAM 在文件方面的区别\n\n1. InnoDB 将一张表存储为两个文件\n\n   - demo.frm -> 存储表的结构和索引\n   - demo.ibd -> 存储数据，ibd 存储是有限的, 存储不足自动创建 ibd1, ibd2\n   - InnoDB 的文件创建在对应的数据库中, 不能任意的移动\n\n2. MyISAM 将一张表存储为三个文件\n\n   - demo.frm -> 存储表的结构\n\n   - demo.myd -> 存储数据\n\n   - demo.myi -> 存储表的索引\n\n   - MyISAM 的文件可以任意的移动\n\n     \n\n# MySQL索引\n\n## 索引介绍\n\n### 索引是什么\n\n- 索引是帮助MySQL**高效获取数据的数据结构**，能**加快数据库检索速度**、**排序**等，类似于一本书的目录。\n\n- 索引本身往往是存储在磁盘上的文件中的（单独的索引文件或者是和数据库一起存储在数据文件中（InnoDB））\n- 包括**聚集索引、覆盖索引、组合索引、前缀索引、唯一索引等**，一般默认使用的都是**B+树结构**的索引\n\n### 索引的优势和劣势\n\n**优势：**\n\n- 可以**提高数据检索的效率**，降低数据库的IO成本；\n- 可以通过索引**对数据进行排序**，降低数据排序的成本，减少CPU消耗；\n  - 被索引的列会自动排序，包括**单列索引**和**组合索引**；\n  - 按照索引列的顺序进行order by **排序效率会提高**很多；\n  - where 索引列 在存储引擎层处理；\n\n**劣势：**\n\n- 会**占用内存空间**；\n- 虽然会提高搜索效率，但是会**降低更新表的效率**，因为每次修改不光要修改表数据，还要修改对应的索引文件；\n\n## 索引的分类\n\n### 单列索引\n\n- 普通索引：MySQL中最基本的索引，没有什么限制，允许在定义索引的列中插入重复值的空值，纯粹是为了查询更快；(**add index**)\n- 唯一索引：索引中的值必须是唯一的，但是允许为空值；(**add unique index**)\n- 主键索引：特殊的唯一索引，不允许为空值。pk\n\n### 组合索引\n\n- 多个字段组合上创建的索引；(**add index(col1, col2,...)**)\n- 需要遵循**最左前缀原则（最左匹配原则）**\n- 一般**建议使用组合索引代替单列索引（主键除外）**\n\n### 全文索引\n\n只有在MyISAM、InnoDB（5.6以后）上才能使用，而且只能在CHAR、VARCHAR、TEXT类型字段上使用全文索引。\n\n优先级最高，最先执行，不会执行其他索引\n\n### 空间索引\n\n\n\n## 索引的使用\n\n### 创建索引\n\n- 单列索引——普通索引\n\n  ```python\n  CREATE INDEX index_name ON table_name (column_name);\n  ALTER TABLE table_name ADD INDEX index_name (column_name);\n  ```\n\n- 单列索引——唯一索引\n\n  ```python\n  CREATE UNIQUE INDEX index_name ON table_name (column_name);\n  ALTER TABLE table_name ADD UNIQUE INDEX index_name(column_name);\n  ```\n\n- 单列索引——全文索引\n\n  ```python\n  CREATE UNIQUE FULLTEXT INDEX fulltext_index_name ON table_name (column_name)\n  ```\n\n- 组合索引\n\n  ```python\n  CREATE INDEX index_name ON table_name (column_name_1, column_name_2);\n  ```\n\n  \n\n### 删除索引\n\n```python\nDROP INDEX index_name ON table_name;\n```\n\n### 查看索引\n\n```python \nSHOW INDEX FROM table_name;\n```\n\n\n\n## 索引原理分析\n\n### 索引的存储结构\n\n- 索引是在**存储引擎中实现**的，也就是说使用不同的存储引擎，会使用不同的索引；\n- **MyISAM** 和 **InnoDB** 存储引擎：**只支持 B+TREE 索引**，**默认使用BTREE**，不能更换；\n- MEMORY/HEAP 存储引擎：支持HASH和BTREE索引；\n  (HASH索引比BTREE快，所以MEMORY引擎也更快)\n\n### B树 和 B+树\n\n数据结构演示网址：https://www.cs.usfca.edu/~galles/visualization/Algorithms.html\n\n#### B树\n\n- 定义：\n\n  \n\n#### B+树\n\n- 定义：\n\n  \n\n# MySQL 事务\n\n## 一、事务\n\n- 事务主要处理操作量大、复杂度高、并且关联性强的数据。\n\n- 进行一系列相互关联的操作：删除用户—>删除该用户相关所有的表数据。\n\n- 在MySQL中只有InnoDB存储引擎支持事务。\n- 事务处理可以用来维护数据库的数据完整性，保证成批的SQL语句要么不执行，要么都执行成功。\n\n## 二、事物的四大特性\n\n在写入或更新数据的过程中，为保证事务的正确可靠，必需具备四个特性（ACID）：\n\n1. **原子性**（Atomicity）\n\n   - 事务中的所有操作，要么全部完成，要么全部不执行，不会结束在中间某个环节；\n   - 事务在执行过程中发生错误，会被**回滚（Rollback）**到事务开始时前的状态，执行完成会有提交操作；\n\n2. **一致性**（Consistency）\n\n   ​\t\t事务开始前和事务结束后，数据库的完整性不能被破坏，写入的数据完全符合数据库的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。\n\n3. **隔离性**（Isolation）\n\n   ​\t\t事务并发会相互影响，多个事务同时操作同一个数据时可能会出现的问题：\n\n   - **脏读**：事务A修改了一个数据，但未提交，**事务B读到了事务A未提交的更新结果**，如果事务A提交失败，事务B读到的就是脏数据。\n   - **不可重复读**：在同一个事务中，对于同一个数据读取的结果不一致。比如，**事务B在事务A提交前后读取到的内容不一致**，导致的原因就是并发修改记录。想要避免这种情况，就要**对修改的记录进行加锁**，但这会导致锁竞争加剧，影响性能。另一种方式是通过**MVCC（多版本的并发控制）**可以在无锁的情况下避免不可重复读。\n   - **幻读**：在同一个事务中，同一个查询多次返回的结果不一致。事务A新增了一条记录，事务B在事务A提交前后各执行了一次查询操作，发现后一次比前一次多了一条记录。幻读是由于并发事务增加记录导致的，这个不能像不可重复读通过记录加锁解决，因为对于新增的记录根本无法加锁。需要将事务串行化，才能避免幻读。\n\n   事务的隔离级别从低到高：\n\n   1. **读取未提交 (Read uncommitted)**\n      - 所有事物都可以看到其他未提交事务的执行结果\n      - 性能不好\n      - 会引发**脏读**：读取到未提交的数据\n   2. **读提交 (read committed)**\n      - 大多数数据库的默认隔离级别（MySQL除外）\n      - 满足了隔离：只能看见已提交事务的改变\n      - 会引发**不可重复读**：事务执行过程中数据可能会被其他事务修改并提交\n   3. **可重复读 (repeatable read)**\n      - **MySQL的默认隔离级别**\n      - 同一事务的多个实例在并发读取数据时，会看到同样的数据行\n      - 会引发**幻读**：多事务同时操作会导致多次读取不一致\n      - InnoDB 通过多版本并发控制 (MVCC，Multiversion Concurrency Control) 机制解决幻读问题；\n      - InnoDB 还通过间隙锁解决幻读问题\n   4. **串行化 (Serializable)**\n      - 这是最高的隔离级别\n      - 它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之,它是在每个读的数据行上加上共享锁。MySQL锁总结\n      - 在这个级别，可能导致大量的超时现象和锁竞争\n\n4. **持久性**（Durability）\n\n   事务处理结束后, 对数据的修改就是永久的, 即便系统故障也不会丢失。\n\n## 三、语法和使用\n\n- 开启事务: `BEGIN`或`START TRANSACTION`\n\n- 提交事务: `COMMIT`, 提交会让所有修改生效\n\n- 回滚: `ROLLBACK`, 撤销正在进行的所有未提交的修改\n\n- 创建保存点: `SAVEPOINT identifier`\n\n- 删除保存点: `RELEASE SAVEPOINT identifier`\n\n- 把事务回滚到保存点: `ROLLBACK TO identifier`\n\n- 查询事务的隔离级别: `show variables like '%isolation%';`\n\n- 设置事务的隔离级别: `SET [SESSION | GLOBAL] TRANSACTION ISOLATION LEVEL {READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE}`\n\n  InnoDB 提供的隔离级别有\n\n  - `READ UNCOMMITTED`\n\n  - `READ COMMITTED`\n\n  - `REPEATABLE READ`\n\n  - `SERIALIZABLE`\n\n    \n\n### 示例：\n\n```sql\ncreate table `abc` (\n    id int unsigned primary key auto_increment,\n    name varchar(32) unique,\n    age int unsigned\n) charset=utf8;\n\nbegin;\ninsert into abc (name, age) values ('aa', 11);\ninsert into abc (name, age) values ('bb', 22);\n-- 在事务中查看一下数据\n-- 同时另开一个窗口，连接到 MySQL 查看一下数据是否一样\nselect * from abc;\ncommit;\n\nbegin;\ninsert into abc (name, age) values ('cc', 33);\ninsert into abc (name, age) values ('dd', 44);\nupdate abc set age=77 where name='aa';\n-- 在事务中查看一下数据\nselect * from abc;\nrollback;\n\nselect * from abc;  -- 事务结束后在查看一下数据\n```\n","slug":"MySQL相关总结","published":1,"updated":"2021-02-02T01:56:02.714Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckknh5t9f00003ntybdxl3ya8","content":"<h1 id=\"MySQL-数据库\"><a href=\"#MySQL-数据库\" class=\"headerlink\" title=\"MySQL 数据库\"></a>MySQL 数据库</h1><p>MySQL 是最流行的关系型数据库管理系统，在 WEB 应用方面 MySQL 是最好的 RDBMS(Relational Database Management System：关系数据库管理系统)应用软件之一。</p>\n<a id=\"more\"></a>\n\n<h1 id=\"MySQL存储引擎\"><a href=\"#MySQL存储引擎\" class=\"headerlink\" title=\"MySQL存储引擎\"></a>MySQL存储引擎</h1><h2 id=\"查看当前存储引擎\"><a href=\"#查看当前存储引擎\" class=\"headerlink\" title=\"查看当前存储引擎\"></a>查看当前存储引擎</h2><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">show</span> <span class=\"keyword\">variables</span> <span class=\"keyword\">like</span> <span class=\"string\">&#x27;%storage_engine&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">show</span> <span class=\"keyword\">engines</span>;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"MySQL常用引擎\"><a href=\"#MySQL常用引擎\" class=\"headerlink\" title=\"MySQL常用引擎\"></a>MySQL常用引擎</h2><ol>\n<li><p>InnoDB</p>\n<p>事务型数据库的首选引擎，支持事务安全表（ACID），支持行锁定和外键，InnoDB是默认的MySQL引擎。</p>\n<p>InnoDB主要特性有：</p>\n<ol>\n<li>InnoDB 给 MySQL 提供了具有提交、回滚、崩溃恢复能力的事务安全存储引擎。</li>\n<li>InnoDB 是为处理巨大数据量的最大性能设计。它的 CPU 效率比其他基于磁盘的关系型数据库引擎高。</li>\n<li>InnoDB 存储引擎自带缓冲池，可以将数据和索引缓存在内存中。</li>\n<li>InnoDB 支持外键完整性约束。</li>\n<li>InnoDB 被用在众多需要高性能的大型数据库站点上</li>\n<li>InnoDB 支持行级锁</li>\n</ol>\n</li>\n<li><p>MyISAM</p>\n<p>MyISAM 基于 ISAM 存储引擎，并对其进行扩展。它是在Web、数据仓储和其他应用环境下最常使用的存储引擎之一。MyISAM 拥有较高的插入、查询速度，但不支持事物。</p>\n<p>MyISAM主要特性有：</p>\n<ol>\n<li>大文件支持更好</li>\n<li>当删除、更新、插入混用时，产生更少碎片。</li>\n<li>每个 MyISAM 表最大索引数是64，这可以通过重新编译来改变。每个索引最大的列数是16</li>\n<li>最大的键长度是1000字节。</li>\n<li>BLOB和TEXT列可以被索引</li>\n<li>NULL 被允许在索引的列中，这个值占每个键的0~1个字节</li>\n<li>所有数字键值以高字节优先被存储以允许一个更高的索引压缩</li>\n<li>MyISAM 类型表的 AUTO_INCREMENT 列更新比 InnoDB 类型的 AUTO_INCREMENT 更快</li>\n<li>可以把数据文件和索引文件放在不同目录</li>\n<li>每个字符列可以有不同的字符集</li>\n<li>有 VARCHAR 的表可以固定或动态记录长度</li>\n<li>VARCHAR 和 CHAR 列可以多达 64KB</li>\n<li>只支持表锁</li>\n</ol>\n</li>\n<li><p>MEMORY</p>\n<p>MEMORY 存储引擎将表中的数据存储到内存中，为查询和引用其他表数据提供快速访问。</p>\n</li>\n</ol>\n<h2 id=\"存储引擎的选择\"><a href=\"#存储引擎的选择\" class=\"headerlink\" title=\"存储引擎的选择\"></a>存储引擎的选择</h2><p>一般来说，对插入和并发性能要求较高的，或者需要外键，或者需要事务支持的情况下，需要选择 InnoDB，</p>\n<p>插入较少，查询较多的场景，优先考虑 MyISAM。</p>\n<h3 id=\"使用引擎\"><a href=\"#使用引擎\" class=\"headerlink\" title=\"使用引擎\"></a>使用引擎</h3><p>一般在建表时添加</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">create table abc (</span><br><span class=\"line\">    name char(10)</span><br><span class=\"line\">) engine&#x3D;MyISAM charset&#x3D;utf8;</span><br><span class=\"line\"></span><br><span class=\"line\">create table xyz (</span><br><span class=\"line\">    name char(10)</span><br><span class=\"line\">) engine&#x3D;InnoDB charset&#x3D;utf8;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"InnoDB-和-MyISAM-在文件方面的区别\"><a href=\"#InnoDB-和-MyISAM-在文件方面的区别\" class=\"headerlink\" title=\"InnoDB 和 MyISAM 在文件方面的区别\"></a>InnoDB 和 MyISAM 在文件方面的区别</h3><ol>\n<li><p>InnoDB 将一张表存储为两个文件</p>\n<ul>\n<li>demo.frm -&gt; 存储表的结构和索引</li>\n<li>demo.ibd -&gt; 存储数据，ibd 存储是有限的, 存储不足自动创建 ibd1, ibd2</li>\n<li>InnoDB 的文件创建在对应的数据库中, 不能任意的移动</li>\n</ul>\n</li>\n<li><p>MyISAM 将一张表存储为三个文件</p>\n<ul>\n<li><p>demo.frm -&gt; 存储表的结构</p>\n</li>\n<li><p>demo.myd -&gt; 存储数据</p>\n</li>\n<li><p>demo.myi -&gt; 存储表的索引</p>\n</li>\n<li><p>MyISAM 的文件可以任意的移动</p>\n</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"MySQL索引\"><a href=\"#MySQL索引\" class=\"headerlink\" title=\"MySQL索引\"></a>MySQL索引</h1><h2 id=\"索引介绍\"><a href=\"#索引介绍\" class=\"headerlink\" title=\"索引介绍\"></a>索引介绍</h2><h3 id=\"索引是什么\"><a href=\"#索引是什么\" class=\"headerlink\" title=\"索引是什么\"></a>索引是什么</h3><ul>\n<li><p>索引是帮助MySQL<strong>高效获取数据的数据结构</strong>，能<strong>加快数据库检索速度</strong>、<strong>排序</strong>等，类似于一本书的目录。</p>\n</li>\n<li><p>索引本身往往是存储在磁盘上的文件中的（单独的索引文件或者是和数据库一起存储在数据文件中（InnoDB））</p>\n</li>\n<li><p>包括<strong>聚集索引、覆盖索引、组合索引、前缀索引、唯一索引等</strong>，一般默认使用的都是<strong>B+树结构</strong>的索引</p>\n</li>\n</ul>\n<h3 id=\"索引的优势和劣势\"><a href=\"#索引的优势和劣势\" class=\"headerlink\" title=\"索引的优势和劣势\"></a>索引的优势和劣势</h3><p><strong>优势：</strong></p>\n<ul>\n<li>可以<strong>提高数据检索的效率</strong>，降低数据库的IO成本；</li>\n<li>可以通过索引<strong>对数据进行排序</strong>，降低数据排序的成本，减少CPU消耗；<ul>\n<li>被索引的列会自动排序，包括<strong>单列索引</strong>和<strong>组合索引</strong>；</li>\n<li>按照索引列的顺序进行order by <strong>排序效率会提高</strong>很多；</li>\n<li>where 索引列 在存储引擎层处理；</li>\n</ul>\n</li>\n</ul>\n<p><strong>劣势：</strong></p>\n<ul>\n<li>会<strong>占用内存空间</strong>；</li>\n<li>虽然会提高搜索效率，但是会<strong>降低更新表的效率</strong>，因为每次修改不光要修改表数据，还要修改对应的索引文件；</li>\n</ul>\n<h2 id=\"索引的分类\"><a href=\"#索引的分类\" class=\"headerlink\" title=\"索引的分类\"></a>索引的分类</h2><h3 id=\"单列索引\"><a href=\"#单列索引\" class=\"headerlink\" title=\"单列索引\"></a>单列索引</h3><ul>\n<li>普通索引：MySQL中最基本的索引，没有什么限制，允许在定义索引的列中插入重复值的空值，纯粹是为了查询更快；(<strong>add index</strong>)</li>\n<li>唯一索引：索引中的值必须是唯一的，但是允许为空值；(<strong>add unique index</strong>)</li>\n<li>主键索引：特殊的唯一索引，不允许为空值。pk</li>\n</ul>\n<h3 id=\"组合索引\"><a href=\"#组合索引\" class=\"headerlink\" title=\"组合索引\"></a>组合索引</h3><ul>\n<li>多个字段组合上创建的索引；(<strong>add index(col1, col2,…)</strong>)</li>\n<li>需要遵循<strong>最左前缀原则（最左匹配原则）</strong></li>\n<li>一般<strong>建议使用组合索引代替单列索引（主键除外）</strong></li>\n</ul>\n<h3 id=\"全文索引\"><a href=\"#全文索引\" class=\"headerlink\" title=\"全文索引\"></a>全文索引</h3><p>只有在MyISAM、InnoDB（5.6以后）上才能使用，而且只能在CHAR、VARCHAR、TEXT类型字段上使用全文索引。</p>\n<p>优先级最高，最先执行，不会执行其他索引</p>\n<h3 id=\"空间索引\"><a href=\"#空间索引\" class=\"headerlink\" title=\"空间索引\"></a>空间索引</h3><h2 id=\"索引的使用\"><a href=\"#索引的使用\" class=\"headerlink\" title=\"索引的使用\"></a>索引的使用</h2><h3 id=\"创建索引\"><a href=\"#创建索引\" class=\"headerlink\" title=\"创建索引\"></a>创建索引</h3><ul>\n<li><p>单列索引——普通索引</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CREATE INDEX index_name ON table_name (column_name);</span><br><span class=\"line\">ALTER TABLE table_name ADD INDEX index_name (column_name);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>单列索引——唯一索引</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CREATE UNIQUE INDEX index_name ON table_name (column_name);</span><br><span class=\"line\">ALTER TABLE table_name ADD UNIQUE INDEX index_name(column_name);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>单列索引——全文索引</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CREATE UNIQUE FULLTEXT INDEX fulltext_index_name ON table_name (column_name)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>组合索引</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CREATE INDEX index_name ON table_name (column_name_1, column_name_2);</span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ul>\n<h3 id=\"删除索引\"><a href=\"#删除索引\" class=\"headerlink\" title=\"删除索引\"></a>删除索引</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DROP INDEX index_name ON table_name;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"查看索引\"><a href=\"#查看索引\" class=\"headerlink\" title=\"查看索引\"></a>查看索引</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SHOW INDEX FROM table_name;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"索引原理分析\"><a href=\"#索引原理分析\" class=\"headerlink\" title=\"索引原理分析\"></a>索引原理分析</h2><h3 id=\"索引的存储结构\"><a href=\"#索引的存储结构\" class=\"headerlink\" title=\"索引的存储结构\"></a>索引的存储结构</h3><ul>\n<li>索引是在<strong>存储引擎中实现</strong>的，也就是说使用不同的存储引擎，会使用不同的索引；</li>\n<li><strong>MyISAM</strong> 和 <strong>InnoDB</strong> 存储引擎：<strong>只支持 B+TREE 索引</strong>，<strong>默认使用BTREE</strong>，不能更换；</li>\n<li>MEMORY/HEAP 存储引擎：支持HASH和BTREE索引；<br>(HASH索引比BTREE快，所以MEMORY引擎也更快)</li>\n</ul>\n<h3 id=\"B树-和-B-树\"><a href=\"#B树-和-B-树\" class=\"headerlink\" title=\"B树 和 B+树\"></a>B树 和 B+树</h3><p>数据结构演示网址：<a href=\"https://www.cs.usfca.edu/~galles/visualization/Algorithms.html\">https://www.cs.usfca.edu/~galles/visualization/Algorithms.html</a></p>\n<h4 id=\"B树\"><a href=\"#B树\" class=\"headerlink\" title=\"B树\"></a>B树</h4><ul>\n<li>定义：</li>\n</ul>\n<h4 id=\"B-树\"><a href=\"#B-树\" class=\"headerlink\" title=\"B+树\"></a>B+树</h4><ul>\n<li>定义：</li>\n</ul>\n<h1 id=\"MySQL-事务\"><a href=\"#MySQL-事务\" class=\"headerlink\" title=\"MySQL 事务\"></a>MySQL 事务</h1><h2 id=\"一、事务\"><a href=\"#一、事务\" class=\"headerlink\" title=\"一、事务\"></a>一、事务</h2><ul>\n<li><p>事务主要处理操作量大、复杂度高、并且关联性强的数据。</p>\n</li>\n<li><p>进行一系列相互关联的操作：删除用户—&gt;删除该用户相关所有的表数据。</p>\n</li>\n<li><p>在MySQL中只有InnoDB存储引擎支持事务。</p>\n</li>\n<li><p>事务处理可以用来维护数据库的数据完整性，保证成批的SQL语句要么不执行，要么都执行成功。</p>\n</li>\n</ul>\n<h2 id=\"二、事物的四大特性\"><a href=\"#二、事物的四大特性\" class=\"headerlink\" title=\"二、事物的四大特性\"></a>二、事物的四大特性</h2><p>在写入或更新数据的过程中，为保证事务的正确可靠，必需具备四个特性（ACID）：</p>\n<ol>\n<li><p><strong>原子性</strong>（Atomicity）</p>\n<ul>\n<li>事务中的所有操作，要么全部完成，要么全部不执行，不会结束在中间某个环节；</li>\n<li>事务在执行过程中发生错误，会被<strong>回滚（Rollback）</strong>到事务开始时前的状态，执行完成会有提交操作；</li>\n</ul>\n</li>\n<li><p><strong>一致性</strong>（Consistency）</p>\n<p>​        事务开始前和事务结束后，数据库的完整性不能被破坏，写入的数据完全符合数据库的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。</p>\n</li>\n<li><p><strong>隔离性</strong>（Isolation）</p>\n<p>​        事务并发会相互影响，多个事务同时操作同一个数据时可能会出现的问题：</p>\n<ul>\n<li><strong>脏读</strong>：事务A修改了一个数据，但未提交，<strong>事务B读到了事务A未提交的更新结果</strong>，如果事务A提交失败，事务B读到的就是脏数据。</li>\n<li><strong>不可重复读</strong>：在同一个事务中，对于同一个数据读取的结果不一致。比如，<strong>事务B在事务A提交前后读取到的内容不一致</strong>，导致的原因就是并发修改记录。想要避免这种情况，就要<strong>对修改的记录进行加锁</strong>，但这会导致锁竞争加剧，影响性能。另一种方式是通过<strong>MVCC（多版本的并发控制）</strong>可以在无锁的情况下避免不可重复读。</li>\n<li><strong>幻读</strong>：在同一个事务中，同一个查询多次返回的结果不一致。事务A新增了一条记录，事务B在事务A提交前后各执行了一次查询操作，发现后一次比前一次多了一条记录。幻读是由于并发事务增加记录导致的，这个不能像不可重复读通过记录加锁解决，因为对于新增的记录根本无法加锁。需要将事务串行化，才能避免幻读。</li>\n</ul>\n<p>事务的隔离级别从低到高：</p>\n<ol>\n<li><strong>读取未提交 (Read uncommitted)</strong><ul>\n<li>所有事物都可以看到其他未提交事务的执行结果</li>\n<li>性能不好</li>\n<li>会引发<strong>脏读</strong>：读取到未提交的数据</li>\n</ul>\n</li>\n<li><strong>读提交 (read committed)</strong><ul>\n<li>大多数数据库的默认隔离级别（MySQL除外）</li>\n<li>满足了隔离：只能看见已提交事务的改变</li>\n<li>会引发<strong>不可重复读</strong>：事务执行过程中数据可能会被其他事务修改并提交</li>\n</ul>\n</li>\n<li><strong>可重复读 (repeatable read)</strong><ul>\n<li><strong>MySQL的默认隔离级别</strong></li>\n<li>同一事务的多个实例在并发读取数据时，会看到同样的数据行</li>\n<li>会引发<strong>幻读</strong>：多事务同时操作会导致多次读取不一致</li>\n<li>InnoDB 通过多版本并发控制 (MVCC，Multiversion Concurrency Control) 机制解决幻读问题；</li>\n<li>InnoDB 还通过间隙锁解决幻读问题</li>\n</ul>\n</li>\n<li><strong>串行化 (Serializable)</strong><ul>\n<li>这是最高的隔离级别</li>\n<li>它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之,它是在每个读的数据行上加上共享锁。MySQL锁总结</li>\n<li>在这个级别，可能导致大量的超时现象和锁竞争</li>\n</ul>\n</li>\n</ol>\n</li>\n<li><p><strong>持久性</strong>（Durability）</p>\n<p>事务处理结束后, 对数据的修改就是永久的, 即便系统故障也不会丢失。</p>\n</li>\n</ol>\n<h2 id=\"三、语法和使用\"><a href=\"#三、语法和使用\" class=\"headerlink\" title=\"三、语法和使用\"></a>三、语法和使用</h2><ul>\n<li><p>开启事务: <code>BEGIN</code>或<code>START TRANSACTION</code></p>\n</li>\n<li><p>提交事务: <code>COMMIT</code>, 提交会让所有修改生效</p>\n</li>\n<li><p>回滚: <code>ROLLBACK</code>, 撤销正在进行的所有未提交的修改</p>\n</li>\n<li><p>创建保存点: <code>SAVEPOINT identifier</code></p>\n</li>\n<li><p>删除保存点: <code>RELEASE SAVEPOINT identifier</code></p>\n</li>\n<li><p>把事务回滚到保存点: <code>ROLLBACK TO identifier</code></p>\n</li>\n<li><p>查询事务的隔离级别: <code>show variables like &#39;%isolation%&#39;;</code></p>\n</li>\n<li><p>设置事务的隔离级别: <code>SET [SESSION | GLOBAL] TRANSACTION ISOLATION LEVEL &#123;READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE&#125;</code></p>\n<p>InnoDB 提供的隔离级别有</p>\n<ul>\n<li><p><code>READ UNCOMMITTED</code></p>\n</li>\n<li><p><code>READ COMMITTED</code></p>\n</li>\n<li><p><code>REPEATABLE READ</code></p>\n</li>\n<li><p><code>SERIALIZABLE</code></p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"示例：\"><a href=\"#示例：\" class=\"headerlink\" title=\"示例：\"></a>示例：</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">table</span> <span class=\"string\">`abc`</span> (</span><br><span class=\"line\">    <span class=\"keyword\">id</span> <span class=\"built_in\">int</span> <span class=\"keyword\">unsigned</span> primary <span class=\"keyword\">key</span> auto_increment,</span><br><span class=\"line\">    <span class=\"keyword\">name</span> <span class=\"built_in\">varchar</span>(<span class=\"number\">32</span>) <span class=\"keyword\">unique</span>,</span><br><span class=\"line\">    age <span class=\"built_in\">int</span> <span class=\"keyword\">unsigned</span></span><br><span class=\"line\">) <span class=\"keyword\">charset</span>=utf8;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">begin</span>;</span><br><span class=\"line\"><span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> abc (<span class=\"keyword\">name</span>, age) <span class=\"keyword\">values</span> (<span class=\"string\">&#x27;aa&#x27;</span>, <span class=\"number\">11</span>);</span><br><span class=\"line\"><span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> abc (<span class=\"keyword\">name</span>, age) <span class=\"keyword\">values</span> (<span class=\"string\">&#x27;bb&#x27;</span>, <span class=\"number\">22</span>);</span><br><span class=\"line\"><span class=\"comment\">-- 在事务中查看一下数据</span></span><br><span class=\"line\"><span class=\"comment\">-- 同时另开一个窗口，连接到 MySQL 查看一下数据是否一样</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> abc;</span><br><span class=\"line\"><span class=\"keyword\">commit</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">begin</span>;</span><br><span class=\"line\"><span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> abc (<span class=\"keyword\">name</span>, age) <span class=\"keyword\">values</span> (<span class=\"string\">&#x27;cc&#x27;</span>, <span class=\"number\">33</span>);</span><br><span class=\"line\"><span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> abc (<span class=\"keyword\">name</span>, age) <span class=\"keyword\">values</span> (<span class=\"string\">&#x27;dd&#x27;</span>, <span class=\"number\">44</span>);</span><br><span class=\"line\"><span class=\"keyword\">update</span> abc <span class=\"keyword\">set</span> age=<span class=\"number\">77</span> <span class=\"keyword\">where</span> <span class=\"keyword\">name</span>=<span class=\"string\">&#x27;aa&#x27;</span>;</span><br><span class=\"line\"><span class=\"comment\">-- 在事务中查看一下数据</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> abc;</span><br><span class=\"line\"><span class=\"keyword\">rollback</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> abc;  <span class=\"comment\">-- 事务结束后在查看一下数据</span></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h1 id=\"MySQL-数据库\"><a href=\"#MySQL-数据库\" class=\"headerlink\" title=\"MySQL 数据库\"></a>MySQL 数据库</h1><p>MySQL 是最流行的关系型数据库管理系统，在 WEB 应用方面 MySQL 是最好的 RDBMS(Relational Database Management System：关系数据库管理系统)应用软件之一。</p>","more":"<h1 id=\"MySQL存储引擎\"><a href=\"#MySQL存储引擎\" class=\"headerlink\" title=\"MySQL存储引擎\"></a>MySQL存储引擎</h1><h2 id=\"查看当前存储引擎\"><a href=\"#查看当前存储引擎\" class=\"headerlink\" title=\"查看当前存储引擎\"></a>查看当前存储引擎</h2><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">show</span> <span class=\"keyword\">variables</span> <span class=\"keyword\">like</span> <span class=\"string\">&#x27;%storage_engine&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">show</span> <span class=\"keyword\">engines</span>;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"MySQL常用引擎\"><a href=\"#MySQL常用引擎\" class=\"headerlink\" title=\"MySQL常用引擎\"></a>MySQL常用引擎</h2><ol>\n<li><p>InnoDB</p>\n<p>事务型数据库的首选引擎，支持事务安全表（ACID），支持行锁定和外键，InnoDB是默认的MySQL引擎。</p>\n<p>InnoDB主要特性有：</p>\n<ol>\n<li>InnoDB 给 MySQL 提供了具有提交、回滚、崩溃恢复能力的事务安全存储引擎。</li>\n<li>InnoDB 是为处理巨大数据量的最大性能设计。它的 CPU 效率比其他基于磁盘的关系型数据库引擎高。</li>\n<li>InnoDB 存储引擎自带缓冲池，可以将数据和索引缓存在内存中。</li>\n<li>InnoDB 支持外键完整性约束。</li>\n<li>InnoDB 被用在众多需要高性能的大型数据库站点上</li>\n<li>InnoDB 支持行级锁</li>\n</ol>\n</li>\n<li><p>MyISAM</p>\n<p>MyISAM 基于 ISAM 存储引擎，并对其进行扩展。它是在Web、数据仓储和其他应用环境下最常使用的存储引擎之一。MyISAM 拥有较高的插入、查询速度，但不支持事物。</p>\n<p>MyISAM主要特性有：</p>\n<ol>\n<li>大文件支持更好</li>\n<li>当删除、更新、插入混用时，产生更少碎片。</li>\n<li>每个 MyISAM 表最大索引数是64，这可以通过重新编译来改变。每个索引最大的列数是16</li>\n<li>最大的键长度是1000字节。</li>\n<li>BLOB和TEXT列可以被索引</li>\n<li>NULL 被允许在索引的列中，这个值占每个键的0~1个字节</li>\n<li>所有数字键值以高字节优先被存储以允许一个更高的索引压缩</li>\n<li>MyISAM 类型表的 AUTO_INCREMENT 列更新比 InnoDB 类型的 AUTO_INCREMENT 更快</li>\n<li>可以把数据文件和索引文件放在不同目录</li>\n<li>每个字符列可以有不同的字符集</li>\n<li>有 VARCHAR 的表可以固定或动态记录长度</li>\n<li>VARCHAR 和 CHAR 列可以多达 64KB</li>\n<li>只支持表锁</li>\n</ol>\n</li>\n<li><p>MEMORY</p>\n<p>MEMORY 存储引擎将表中的数据存储到内存中，为查询和引用其他表数据提供快速访问。</p>\n</li>\n</ol>\n<h2 id=\"存储引擎的选择\"><a href=\"#存储引擎的选择\" class=\"headerlink\" title=\"存储引擎的选择\"></a>存储引擎的选择</h2><p>一般来说，对插入和并发性能要求较高的，或者需要外键，或者需要事务支持的情况下，需要选择 InnoDB，</p>\n<p>插入较少，查询较多的场景，优先考虑 MyISAM。</p>\n<h3 id=\"使用引擎\"><a href=\"#使用引擎\" class=\"headerlink\" title=\"使用引擎\"></a>使用引擎</h3><p>一般在建表时添加</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">create table abc (</span><br><span class=\"line\">    name char(10)</span><br><span class=\"line\">) engine&#x3D;MyISAM charset&#x3D;utf8;</span><br><span class=\"line\"></span><br><span class=\"line\">create table xyz (</span><br><span class=\"line\">    name char(10)</span><br><span class=\"line\">) engine&#x3D;InnoDB charset&#x3D;utf8;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"InnoDB-和-MyISAM-在文件方面的区别\"><a href=\"#InnoDB-和-MyISAM-在文件方面的区别\" class=\"headerlink\" title=\"InnoDB 和 MyISAM 在文件方面的区别\"></a>InnoDB 和 MyISAM 在文件方面的区别</h3><ol>\n<li><p>InnoDB 将一张表存储为两个文件</p>\n<ul>\n<li>demo.frm -&gt; 存储表的结构和索引</li>\n<li>demo.ibd -&gt; 存储数据，ibd 存储是有限的, 存储不足自动创建 ibd1, ibd2</li>\n<li>InnoDB 的文件创建在对应的数据库中, 不能任意的移动</li>\n</ul>\n</li>\n<li><p>MyISAM 将一张表存储为三个文件</p>\n<ul>\n<li><p>demo.frm -&gt; 存储表的结构</p>\n</li>\n<li><p>demo.myd -&gt; 存储数据</p>\n</li>\n<li><p>demo.myi -&gt; 存储表的索引</p>\n</li>\n<li><p>MyISAM 的文件可以任意的移动</p>\n</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"MySQL索引\"><a href=\"#MySQL索引\" class=\"headerlink\" title=\"MySQL索引\"></a>MySQL索引</h1><h2 id=\"索引介绍\"><a href=\"#索引介绍\" class=\"headerlink\" title=\"索引介绍\"></a>索引介绍</h2><h3 id=\"索引是什么\"><a href=\"#索引是什么\" class=\"headerlink\" title=\"索引是什么\"></a>索引是什么</h3><ul>\n<li><p>索引是帮助MySQL<strong>高效获取数据的数据结构</strong>，能<strong>加快数据库检索速度</strong>、<strong>排序</strong>等，类似于一本书的目录。</p>\n</li>\n<li><p>索引本身往往是存储在磁盘上的文件中的（单独的索引文件或者是和数据库一起存储在数据文件中（InnoDB））</p>\n</li>\n<li><p>包括<strong>聚集索引、覆盖索引、组合索引、前缀索引、唯一索引等</strong>，一般默认使用的都是<strong>B+树结构</strong>的索引</p>\n</li>\n</ul>\n<h3 id=\"索引的优势和劣势\"><a href=\"#索引的优势和劣势\" class=\"headerlink\" title=\"索引的优势和劣势\"></a>索引的优势和劣势</h3><p><strong>优势：</strong></p>\n<ul>\n<li>可以<strong>提高数据检索的效率</strong>，降低数据库的IO成本；</li>\n<li>可以通过索引<strong>对数据进行排序</strong>，降低数据排序的成本，减少CPU消耗；<ul>\n<li>被索引的列会自动排序，包括<strong>单列索引</strong>和<strong>组合索引</strong>；</li>\n<li>按照索引列的顺序进行order by <strong>排序效率会提高</strong>很多；</li>\n<li>where 索引列 在存储引擎层处理；</li>\n</ul>\n</li>\n</ul>\n<p><strong>劣势：</strong></p>\n<ul>\n<li>会<strong>占用内存空间</strong>；</li>\n<li>虽然会提高搜索效率，但是会<strong>降低更新表的效率</strong>，因为每次修改不光要修改表数据，还要修改对应的索引文件；</li>\n</ul>\n<h2 id=\"索引的分类\"><a href=\"#索引的分类\" class=\"headerlink\" title=\"索引的分类\"></a>索引的分类</h2><h3 id=\"单列索引\"><a href=\"#单列索引\" class=\"headerlink\" title=\"单列索引\"></a>单列索引</h3><ul>\n<li>普通索引：MySQL中最基本的索引，没有什么限制，允许在定义索引的列中插入重复值的空值，纯粹是为了查询更快；(<strong>add index</strong>)</li>\n<li>唯一索引：索引中的值必须是唯一的，但是允许为空值；(<strong>add unique index</strong>)</li>\n<li>主键索引：特殊的唯一索引，不允许为空值。pk</li>\n</ul>\n<h3 id=\"组合索引\"><a href=\"#组合索引\" class=\"headerlink\" title=\"组合索引\"></a>组合索引</h3><ul>\n<li>多个字段组合上创建的索引；(<strong>add index(col1, col2,…)</strong>)</li>\n<li>需要遵循<strong>最左前缀原则（最左匹配原则）</strong></li>\n<li>一般<strong>建议使用组合索引代替单列索引（主键除外）</strong></li>\n</ul>\n<h3 id=\"全文索引\"><a href=\"#全文索引\" class=\"headerlink\" title=\"全文索引\"></a>全文索引</h3><p>只有在MyISAM、InnoDB（5.6以后）上才能使用，而且只能在CHAR、VARCHAR、TEXT类型字段上使用全文索引。</p>\n<p>优先级最高，最先执行，不会执行其他索引</p>\n<h3 id=\"空间索引\"><a href=\"#空间索引\" class=\"headerlink\" title=\"空间索引\"></a>空间索引</h3><h2 id=\"索引的使用\"><a href=\"#索引的使用\" class=\"headerlink\" title=\"索引的使用\"></a>索引的使用</h2><h3 id=\"创建索引\"><a href=\"#创建索引\" class=\"headerlink\" title=\"创建索引\"></a>创建索引</h3><ul>\n<li><p>单列索引——普通索引</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CREATE INDEX index_name ON table_name (column_name);</span><br><span class=\"line\">ALTER TABLE table_name ADD INDEX index_name (column_name);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>单列索引——唯一索引</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CREATE UNIQUE INDEX index_name ON table_name (column_name);</span><br><span class=\"line\">ALTER TABLE table_name ADD UNIQUE INDEX index_name(column_name);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>单列索引——全文索引</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CREATE UNIQUE FULLTEXT INDEX fulltext_index_name ON table_name (column_name)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>组合索引</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CREATE INDEX index_name ON table_name (column_name_1, column_name_2);</span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ul>\n<h3 id=\"删除索引\"><a href=\"#删除索引\" class=\"headerlink\" title=\"删除索引\"></a>删除索引</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DROP INDEX index_name ON table_name;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"查看索引\"><a href=\"#查看索引\" class=\"headerlink\" title=\"查看索引\"></a>查看索引</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SHOW INDEX FROM table_name;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"索引原理分析\"><a href=\"#索引原理分析\" class=\"headerlink\" title=\"索引原理分析\"></a>索引原理分析</h2><h3 id=\"索引的存储结构\"><a href=\"#索引的存储结构\" class=\"headerlink\" title=\"索引的存储结构\"></a>索引的存储结构</h3><ul>\n<li>索引是在<strong>存储引擎中实现</strong>的，也就是说使用不同的存储引擎，会使用不同的索引；</li>\n<li><strong>MyISAM</strong> 和 <strong>InnoDB</strong> 存储引擎：<strong>只支持 B+TREE 索引</strong>，<strong>默认使用BTREE</strong>，不能更换；</li>\n<li>MEMORY/HEAP 存储引擎：支持HASH和BTREE索引；<br>(HASH索引比BTREE快，所以MEMORY引擎也更快)</li>\n</ul>\n<h3 id=\"B树-和-B-树\"><a href=\"#B树-和-B-树\" class=\"headerlink\" title=\"B树 和 B+树\"></a>B树 和 B+树</h3><p>数据结构演示网址：<a href=\"https://www.cs.usfca.edu/~galles/visualization/Algorithms.html\">https://www.cs.usfca.edu/~galles/visualization/Algorithms.html</a></p>\n<h4 id=\"B树\"><a href=\"#B树\" class=\"headerlink\" title=\"B树\"></a>B树</h4><ul>\n<li>定义：</li>\n</ul>\n<h4 id=\"B-树\"><a href=\"#B-树\" class=\"headerlink\" title=\"B+树\"></a>B+树</h4><ul>\n<li>定义：</li>\n</ul>\n<h1 id=\"MySQL-事务\"><a href=\"#MySQL-事务\" class=\"headerlink\" title=\"MySQL 事务\"></a>MySQL 事务</h1><h2 id=\"一、事务\"><a href=\"#一、事务\" class=\"headerlink\" title=\"一、事务\"></a>一、事务</h2><ul>\n<li><p>事务主要处理操作量大、复杂度高、并且关联性强的数据。</p>\n</li>\n<li><p>进行一系列相互关联的操作：删除用户—&gt;删除该用户相关所有的表数据。</p>\n</li>\n<li><p>在MySQL中只有InnoDB存储引擎支持事务。</p>\n</li>\n<li><p>事务处理可以用来维护数据库的数据完整性，保证成批的SQL语句要么不执行，要么都执行成功。</p>\n</li>\n</ul>\n<h2 id=\"二、事物的四大特性\"><a href=\"#二、事物的四大特性\" class=\"headerlink\" title=\"二、事物的四大特性\"></a>二、事物的四大特性</h2><p>在写入或更新数据的过程中，为保证事务的正确可靠，必需具备四个特性（ACID）：</p>\n<ol>\n<li><p><strong>原子性</strong>（Atomicity）</p>\n<ul>\n<li>事务中的所有操作，要么全部完成，要么全部不执行，不会结束在中间某个环节；</li>\n<li>事务在执行过程中发生错误，会被<strong>回滚（Rollback）</strong>到事务开始时前的状态，执行完成会有提交操作；</li>\n</ul>\n</li>\n<li><p><strong>一致性</strong>（Consistency）</p>\n<p>​        事务开始前和事务结束后，数据库的完整性不能被破坏，写入的数据完全符合数据库的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。</p>\n</li>\n<li><p><strong>隔离性</strong>（Isolation）</p>\n<p>​        事务并发会相互影响，多个事务同时操作同一个数据时可能会出现的问题：</p>\n<ul>\n<li><strong>脏读</strong>：事务A修改了一个数据，但未提交，<strong>事务B读到了事务A未提交的更新结果</strong>，如果事务A提交失败，事务B读到的就是脏数据。</li>\n<li><strong>不可重复读</strong>：在同一个事务中，对于同一个数据读取的结果不一致。比如，<strong>事务B在事务A提交前后读取到的内容不一致</strong>，导致的原因就是并发修改记录。想要避免这种情况，就要<strong>对修改的记录进行加锁</strong>，但这会导致锁竞争加剧，影响性能。另一种方式是通过<strong>MVCC（多版本的并发控制）</strong>可以在无锁的情况下避免不可重复读。</li>\n<li><strong>幻读</strong>：在同一个事务中，同一个查询多次返回的结果不一致。事务A新增了一条记录，事务B在事务A提交前后各执行了一次查询操作，发现后一次比前一次多了一条记录。幻读是由于并发事务增加记录导致的，这个不能像不可重复读通过记录加锁解决，因为对于新增的记录根本无法加锁。需要将事务串行化，才能避免幻读。</li>\n</ul>\n<p>事务的隔离级别从低到高：</p>\n<ol>\n<li><strong>读取未提交 (Read uncommitted)</strong><ul>\n<li>所有事物都可以看到其他未提交事务的执行结果</li>\n<li>性能不好</li>\n<li>会引发<strong>脏读</strong>：读取到未提交的数据</li>\n</ul>\n</li>\n<li><strong>读提交 (read committed)</strong><ul>\n<li>大多数数据库的默认隔离级别（MySQL除外）</li>\n<li>满足了隔离：只能看见已提交事务的改变</li>\n<li>会引发<strong>不可重复读</strong>：事务执行过程中数据可能会被其他事务修改并提交</li>\n</ul>\n</li>\n<li><strong>可重复读 (repeatable read)</strong><ul>\n<li><strong>MySQL的默认隔离级别</strong></li>\n<li>同一事务的多个实例在并发读取数据时，会看到同样的数据行</li>\n<li>会引发<strong>幻读</strong>：多事务同时操作会导致多次读取不一致</li>\n<li>InnoDB 通过多版本并发控制 (MVCC，Multiversion Concurrency Control) 机制解决幻读问题；</li>\n<li>InnoDB 还通过间隙锁解决幻读问题</li>\n</ul>\n</li>\n<li><strong>串行化 (Serializable)</strong><ul>\n<li>这是最高的隔离级别</li>\n<li>它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之,它是在每个读的数据行上加上共享锁。MySQL锁总结</li>\n<li>在这个级别，可能导致大量的超时现象和锁竞争</li>\n</ul>\n</li>\n</ol>\n</li>\n<li><p><strong>持久性</strong>（Durability）</p>\n<p>事务处理结束后, 对数据的修改就是永久的, 即便系统故障也不会丢失。</p>\n</li>\n</ol>\n<h2 id=\"三、语法和使用\"><a href=\"#三、语法和使用\" class=\"headerlink\" title=\"三、语法和使用\"></a>三、语法和使用</h2><ul>\n<li><p>开启事务: <code>BEGIN</code>或<code>START TRANSACTION</code></p>\n</li>\n<li><p>提交事务: <code>COMMIT</code>, 提交会让所有修改生效</p>\n</li>\n<li><p>回滚: <code>ROLLBACK</code>, 撤销正在进行的所有未提交的修改</p>\n</li>\n<li><p>创建保存点: <code>SAVEPOINT identifier</code></p>\n</li>\n<li><p>删除保存点: <code>RELEASE SAVEPOINT identifier</code></p>\n</li>\n<li><p>把事务回滚到保存点: <code>ROLLBACK TO identifier</code></p>\n</li>\n<li><p>查询事务的隔离级别: <code>show variables like &#39;%isolation%&#39;;</code></p>\n</li>\n<li><p>设置事务的隔离级别: <code>SET [SESSION | GLOBAL] TRANSACTION ISOLATION LEVEL &#123;READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE&#125;</code></p>\n<p>InnoDB 提供的隔离级别有</p>\n<ul>\n<li><p><code>READ UNCOMMITTED</code></p>\n</li>\n<li><p><code>READ COMMITTED</code></p>\n</li>\n<li><p><code>REPEATABLE READ</code></p>\n</li>\n<li><p><code>SERIALIZABLE</code></p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"示例：\"><a href=\"#示例：\" class=\"headerlink\" title=\"示例：\"></a>示例：</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">table</span> <span class=\"string\">`abc`</span> (</span><br><span class=\"line\">    <span class=\"keyword\">id</span> <span class=\"built_in\">int</span> <span class=\"keyword\">unsigned</span> primary <span class=\"keyword\">key</span> auto_increment,</span><br><span class=\"line\">    <span class=\"keyword\">name</span> <span class=\"built_in\">varchar</span>(<span class=\"number\">32</span>) <span class=\"keyword\">unique</span>,</span><br><span class=\"line\">    age <span class=\"built_in\">int</span> <span class=\"keyword\">unsigned</span></span><br><span class=\"line\">) <span class=\"keyword\">charset</span>=utf8;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">begin</span>;</span><br><span class=\"line\"><span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> abc (<span class=\"keyword\">name</span>, age) <span class=\"keyword\">values</span> (<span class=\"string\">&#x27;aa&#x27;</span>, <span class=\"number\">11</span>);</span><br><span class=\"line\"><span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> abc (<span class=\"keyword\">name</span>, age) <span class=\"keyword\">values</span> (<span class=\"string\">&#x27;bb&#x27;</span>, <span class=\"number\">22</span>);</span><br><span class=\"line\"><span class=\"comment\">-- 在事务中查看一下数据</span></span><br><span class=\"line\"><span class=\"comment\">-- 同时另开一个窗口，连接到 MySQL 查看一下数据是否一样</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> abc;</span><br><span class=\"line\"><span class=\"keyword\">commit</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">begin</span>;</span><br><span class=\"line\"><span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> abc (<span class=\"keyword\">name</span>, age) <span class=\"keyword\">values</span> (<span class=\"string\">&#x27;cc&#x27;</span>, <span class=\"number\">33</span>);</span><br><span class=\"line\"><span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> abc (<span class=\"keyword\">name</span>, age) <span class=\"keyword\">values</span> (<span class=\"string\">&#x27;dd&#x27;</span>, <span class=\"number\">44</span>);</span><br><span class=\"line\"><span class=\"keyword\">update</span> abc <span class=\"keyword\">set</span> age=<span class=\"number\">77</span> <span class=\"keyword\">where</span> <span class=\"keyword\">name</span>=<span class=\"string\">&#x27;aa&#x27;</span>;</span><br><span class=\"line\"><span class=\"comment\">-- 在事务中查看一下数据</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> abc;</span><br><span class=\"line\"><span class=\"keyword\">rollback</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> abc;  <span class=\"comment\">-- 事务结束后在查看一下数据</span></span><br></pre></td></tr></table></figure>"},{"title":"Hello World","top":true,"_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n<!--more-->\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\ntop: true\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n<!--more-->\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","slug":"hello-world","published":1,"date":"2021-02-02T01:56:02.530Z","updated":"2021-02-02T01:56:02.530Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckknh5t9o00013ntyeuhr0njw","content":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<a id=\"more\"></a>\n\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>","more":"<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>"},{"title":"文件操作","date":"2020-08-01T07:45:03.000Z","_content":"\n# 文件操作\n\n关于在Python中对文件相关操作的记录\n\n<!--more-->\n\n# 文件的打开\n\n在python中可以使用open函数打开一个已经存在的文件，或者创建一个新文件。\n\n```python\nfile = open('../a.txt', 'w')\n```\n\n## 访问模式\n\n```python\nopen(file, mode='r', buffering=None, encoding=None, errors=None, newline=None, closefd=True)\n```\n\n|   访问模式   | 说明                                                         |\n| :----------: | :----------------------------------------------------------- |\n|      r       | 只读——已存在则从头开始——不存在则报错——读完不重新open文件指针不会复原<br />这是默认模式。** |\n|      w       | 只写——已存在则覆写——不存在则创建新文件——同一次文件指针不会复原（等同于追加）——重新open就会覆写 |\n|      a       | 追加——已存在则追加原内容之后——不存在则创建新文件——只写不读   |\n|      r+      | 读写——文件指针默认在文件开始位置，写入会覆盖相同长度的原内容——操作之后文件指针不会复原 |\n|      w+      | 读写——文件已存在则将其覆盖——文件不存在则创建新文件——每次open都是清空原内容，但是写入操作之后文件指针在文件末，此时读会为空，需要重置指针 |\n|      a+      | 追加方式读写——文件已存在，文件指针将会放在文件的结尾，可以直接追加，所以读为空——文件不存在，创建新文件用于读写 |\n|      b       | 二进制格式操作                                               |\n|      t       | 文本模式                                                     |\n|      U       | 通用换行符，将所有的\\n、\\r 都替换成 \\n<br />（universal newline mode (deprecated)） |\n|  buffering   | 为了减少I/O操作，使用缓冲区，达到要求的数据量才进行系统调用<br />全缓冲：buffering=1024        设置大于1的整数表示缓冲区大小<br />行缓冲：buffering=1        按行缓冲，适用于文本内容<br />无缓冲：buffering=0        来一个处理一个，只适用于二进制模式 |\n|   encoding   | 返回数据采用何种编码方式进行解码——‘utf-8’、‘gbk’             |\n|    errors    | 取值一般有strict，ignore，当取strict的时候，字符编码出现问题的时候，会报错，当取ignore的时候，编码出现问题，程序会忽略而过，继续执行下面的程序 |\n|   newline    | 可以取的值有None, \\n, \\r, ”, ‘\\r\\n’，用于区分换行符，但是这个参数只对文本模式有效 |\n| 文件指针操作 | file.tell    查看指针当前位置<br />file.seek(0)    将指针移到文件开头 |\n\n# 文件关闭\n\n文件打开之后一定要关闭\n\n```python\nfile.close()\n```\n\n# 文件的读写\n\n## 写数据\n\n使用 write() 向文件写数据\n\n```python\nfile.open('test.txt', 'w')\nfile.write('hello world, i am here!\\n' * 5)\nfile.close()\n```\n\n## 读数据\n\n使用read(num)可以从文件中读取数据，num表示读取的数据长度，单位是字节。\n\n```python\none_k = file.read(1024)\nprint(one_k)\n# 同一次open内不会还原文件指针位置\n# 会读取接下来的所有内容\nlast = file.read()\nprint(last)\n```\n\n使用readlines() 可以按照行的方式将整个文件的内容进行一次性读取，返回一个列表，每一行为列表的一个元素。\n\n```python\ncontent = f.readlines()\nprint(type(content))\n\nfor temp in content:\n    print(temp)\n```\n\n## 重置指针位置\n\nseek(offset, whence) 方法重置文件指针的位置\n\n- offset：表示偏移量\n- whence：表示指针移动位置，只能传入0、1、2\n  - 0表示从文件头开始\n  - 1表示从当前位置开始，配合偏移量使用\n  - 2表示从文件末尾开始\n\n```python\nf.seek(2,0)   # 从文件的开头开始，跳过两个字节\nprint(f.read())\n\nf.seek(1,1) # 从当前位置开始，跳过一个字节\nprint(f.read())\n\nf.seek(-4,2) # 从文件末尾开始，往前跳过四个字节\nprint(f.read())\n```\n\n# CSV文件\n\n```python\nimport csv\n\n# 先以写入模式打开一个csv文件\ncsvfile = open('tst.csv', 'w')\n\n# csv的writer方法将文件对象变成CSVWriter对象\ncsvwriter = csv.writer(file)\n\n# 调用CSVWriter的writerow方法可以按行写入数据\ncsvwrite.writerow(['name', 'age', 'score'])\n\n# writerows方法可以一次性写入多行\ncsvwriter.writerows(['zhangsan', '18', '98'], ['lisi', '19', '99'], ['wangwu', '18', '97'])\n\n# 调用csv模块的reader方法，得到的结果是一个可迭代对象\nreader = csv.reader(file)\n\n# 对结果进行遍历，获取到结果里的每一行数据\nfor row in reader:\n    print(row)\n\nfile.close()\n```\n\n# 数据写入内存\n\n## StringIO\n\nStringIO可以将字符串写入到内存中，像操作文件一下操作字符串。\n\n```python\nfrom io import StringIO\n\n# 创建一个StringIO对象\nf = StringIO()\n# 可以像操作文件一下，将字符串写入到内存中\nf.write('hello\\r\\n')\nf.write('good')\n\n# 使用文件的 readline和readlines方法，无法读取到数据\n# print(f.readline())\n# print(f.readlines())\n\n# 需要调用getvalue()方法才能获取到写入到内存中的数据\nprint(f.getvalue())\n\nf.close()\n```\n\n## BytesIO\n\n如果想要以二进制的形式写入数据，可以使用BytesIO类，它的用法和StringIO相似，只不过在调用write方法写入时，**需要传入二进制数据**。\n\n```python\nfrom io import BytesIO\n\nf = BytesIO()\nf.write('你好\\r\\n'.encode('utf-8'))\nf.write('中国'.encode('utf-8'))\n\nprint(f.getvalue())\nf.close()\n```\n\n# 序列化和反序列化\n\n将对象序列化之后才能写入文件，也可以将文件中的字节（字符）反序列化为python对象（列表、字典、元组。。。）\n\n## JSON模块序列化\n\nJSON(JavaScriptObjectNotation, JS对象简谱)是一种轻量级的数据交换格式，它基于 ECMAScript 的一个子集，采用完全独立于编程语言的**文本格式**来存储和表示数据。**JSON的本质是字符串**！\n\n### dump/dumps方法实现序列化\n\ndumps方法可以将对象转化为字符串，并不具备写入文件的功能\n\n```python\nimport json\n\nfile = open('text.txt', 'w')\n\nnames = ['zhangsan', 'lisi', 'wangwu', 'merry', 'jack']\n# file.write(names)    出错，不能直接将列表写入文件中\n\n# 调用json的dumps方法，传入对象，返回json字符串\njson_result = json.dumps(names)\n\nprint(type(json_result))    # <class 'str'>\n\nfile.write(json_result)\n\nfile.close()\n```\n\ndump方法可以在将对象转换成为字符串的同时，指定一个文件对象，把转换后的字符串写入到这个文件里。\n\n```python\nimport json\n\nfile = open('names.txt', 'w')\nnames = ['zhangsan', 'lisi', 'wangwu', 'jerry', 'henry', 'merry', 'chris']\n\n# dump方法可以接收一个文件参数，在将对象转换成为字符串的同时写入到文件里\njson.dump(names, file)\nfile.close()\n```\n\n注意：如果是一个空对象，调用dumps方法转换成为一个JSON对象，得到的结果是null(JS里的空对象)\n\n### load/loads方法实现反序列化\n\nloads方法需要一个字符串参数，用来将一个字符串加载成为Python对象。\n\n```python\nimport json\n\n# 调用loads方法，传入一个字符串，可以将这个字符串加载成为Python对象\nresult = json.loads('[\"zhangsan\", \"lisi\", \"wangwu\", \"jerry\", \"henry\", \"merry\", \"chris\"]')\nprint(type(result))  # <class 'list'>\nCopy\n```\n\nload方法可以传入一个文件对象，用来将一个文件对象里的数据加载成为Python对象。\n\n```python\nimport json\n\n# 以可读方式打开一个文件\nfile = open('names.txt', 'r')\n\n# 调用load方法，将文件里的内容加载成为一个Python对象\nresult = json.load(file)\n\nprint(result)\nfile.close()\n```\n\n## pickle模块序列化\n\n和json模块类似，pickle模块也有dump和dumps方法可以对数据进行序列化，同时也有load和loads方法进行反序列化。区别在于，json模块是将对象转换成为字符串，而pickle模块是将对象转换成为二进制。\n\npickle模块里方法的使用和json里方法的使用大致相同，需要注意的是，**pickle是将对象转换成为二进制，所以，如果想要把内容写入到文件里，这个文件必须要以二进制的形式打开。**\n\n## json和pickle的区别\n\n- json模块:\n\n  - 将对象转化为字符串，而字符串在任何系统和编程语言中都是可以识别的；\n  - json的用处就是跨平台信息传输；\n  - python对象与json字符串对应关系：\n\n  | Python     | JSON   |\n  | ---------- | ------ |\n  | dict       | object |\n  | list,tuple | array  |\n  | str        | string |\n  | int,float  | number |\n  | True       | true   |\n  | False      | false  |\n  | None       | null   |\n\n- 如果是一个自定义对象，默认无法装换成为json字符串，需要手动指定JSONEncoder.\n\n- 如果是将一个json串重新转换成为对象，这个对象里的方法就无法使用了。\n\n  ```python\n  import json\n  class MyEncode(json.JSONEncoder):\n      def default(self, o):\n          # return {\"name\":o.name,\"age\":o.age}\n          return o.__dict__\n  \n  class Person(object):\n      def __init__(self, name, age):\n          self.name = name\n          self.age = age\n  \n        def eat(self):\n            print(self.name+'正在吃东西')\n  \n  p1 = Person('zhangsan', 18)\n  \n  # 自定义对象想要转换成为json字符串，需要给这个自定义对象指定JSONEncoder\n  result = json.dumps(p1, cls=MyEncode)\n  print(result)  # {\"name\": \"zhangsan\", \"age\": 18}\n  \n  # 调用loads方法将对象加载成为一个对象以后，得到的结果是一个字典\n  p = json.loads(result)\n  print(type(p))\n  Copy\n  ```\n\n- pickle模块：\n  - pickle序列化是将对象按照一定的规则转换成为二进制保存，它不能跨平台传递数据。\n  - pickle的序列化会将对象的所有数据都保存。\n  - pickle适合对需要使用的自定义对象进行序列化处理\n  - 深拷贝也可以使用pickle实现\n\n# 使用with关键字\n\nwith语句实质上是一个上下文管理器，with语句后的对象都会有`__enter__()`和`__exit__()`方法。在进入到上下文时，会自动调用`__enter__()`方法，程序正常执行完成，或者出现异常中断的时候，都会调用`__exit__()`方法。\n\n```python\ndef m3():\n    with open(\"output.txt\", \"r\") as f:\n        f.write(\"Python之禅\")\n```\n\nopen 方法的返回值赋值给变量 f，当离开 with 代码块的时候，系统会自动调用 f.close() 方法。\n\n## 上下文管理器\n\n```python\nclass MyContext(object):\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n\n    def __enter__(self):\n        print('调用了enter方法')\n        return self\n\n    def test(self):\n        1 / 0\n        print(self.name + '调用了test方法')\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        print('调用了exit方法')\n        print(exc_type, exc_val, exc_tb)\n\nwith MyContext('zhangsan', 18) as context:\n    context.test()\n```\n","source":"_posts/文件操作.md","raw":"---\ntitle: 文件操作\ndate: 2020-08-01 15:45:03\n---\n\n# 文件操作\n\n关于在Python中对文件相关操作的记录\n\n<!--more-->\n\n# 文件的打开\n\n在python中可以使用open函数打开一个已经存在的文件，或者创建一个新文件。\n\n```python\nfile = open('../a.txt', 'w')\n```\n\n## 访问模式\n\n```python\nopen(file, mode='r', buffering=None, encoding=None, errors=None, newline=None, closefd=True)\n```\n\n|   访问模式   | 说明                                                         |\n| :----------: | :----------------------------------------------------------- |\n|      r       | 只读——已存在则从头开始——不存在则报错——读完不重新open文件指针不会复原<br />这是默认模式。** |\n|      w       | 只写——已存在则覆写——不存在则创建新文件——同一次文件指针不会复原（等同于追加）——重新open就会覆写 |\n|      a       | 追加——已存在则追加原内容之后——不存在则创建新文件——只写不读   |\n|      r+      | 读写——文件指针默认在文件开始位置，写入会覆盖相同长度的原内容——操作之后文件指针不会复原 |\n|      w+      | 读写——文件已存在则将其覆盖——文件不存在则创建新文件——每次open都是清空原内容，但是写入操作之后文件指针在文件末，此时读会为空，需要重置指针 |\n|      a+      | 追加方式读写——文件已存在，文件指针将会放在文件的结尾，可以直接追加，所以读为空——文件不存在，创建新文件用于读写 |\n|      b       | 二进制格式操作                                               |\n|      t       | 文本模式                                                     |\n|      U       | 通用换行符，将所有的\\n、\\r 都替换成 \\n<br />（universal newline mode (deprecated)） |\n|  buffering   | 为了减少I/O操作，使用缓冲区，达到要求的数据量才进行系统调用<br />全缓冲：buffering=1024        设置大于1的整数表示缓冲区大小<br />行缓冲：buffering=1        按行缓冲，适用于文本内容<br />无缓冲：buffering=0        来一个处理一个，只适用于二进制模式 |\n|   encoding   | 返回数据采用何种编码方式进行解码——‘utf-8’、‘gbk’             |\n|    errors    | 取值一般有strict，ignore，当取strict的时候，字符编码出现问题的时候，会报错，当取ignore的时候，编码出现问题，程序会忽略而过，继续执行下面的程序 |\n|   newline    | 可以取的值有None, \\n, \\r, ”, ‘\\r\\n’，用于区分换行符，但是这个参数只对文本模式有效 |\n| 文件指针操作 | file.tell    查看指针当前位置<br />file.seek(0)    将指针移到文件开头 |\n\n# 文件关闭\n\n文件打开之后一定要关闭\n\n```python\nfile.close()\n```\n\n# 文件的读写\n\n## 写数据\n\n使用 write() 向文件写数据\n\n```python\nfile.open('test.txt', 'w')\nfile.write('hello world, i am here!\\n' * 5)\nfile.close()\n```\n\n## 读数据\n\n使用read(num)可以从文件中读取数据，num表示读取的数据长度，单位是字节。\n\n```python\none_k = file.read(1024)\nprint(one_k)\n# 同一次open内不会还原文件指针位置\n# 会读取接下来的所有内容\nlast = file.read()\nprint(last)\n```\n\n使用readlines() 可以按照行的方式将整个文件的内容进行一次性读取，返回一个列表，每一行为列表的一个元素。\n\n```python\ncontent = f.readlines()\nprint(type(content))\n\nfor temp in content:\n    print(temp)\n```\n\n## 重置指针位置\n\nseek(offset, whence) 方法重置文件指针的位置\n\n- offset：表示偏移量\n- whence：表示指针移动位置，只能传入0、1、2\n  - 0表示从文件头开始\n  - 1表示从当前位置开始，配合偏移量使用\n  - 2表示从文件末尾开始\n\n```python\nf.seek(2,0)   # 从文件的开头开始，跳过两个字节\nprint(f.read())\n\nf.seek(1,1) # 从当前位置开始，跳过一个字节\nprint(f.read())\n\nf.seek(-4,2) # 从文件末尾开始，往前跳过四个字节\nprint(f.read())\n```\n\n# CSV文件\n\n```python\nimport csv\n\n# 先以写入模式打开一个csv文件\ncsvfile = open('tst.csv', 'w')\n\n# csv的writer方法将文件对象变成CSVWriter对象\ncsvwriter = csv.writer(file)\n\n# 调用CSVWriter的writerow方法可以按行写入数据\ncsvwrite.writerow(['name', 'age', 'score'])\n\n# writerows方法可以一次性写入多行\ncsvwriter.writerows(['zhangsan', '18', '98'], ['lisi', '19', '99'], ['wangwu', '18', '97'])\n\n# 调用csv模块的reader方法，得到的结果是一个可迭代对象\nreader = csv.reader(file)\n\n# 对结果进行遍历，获取到结果里的每一行数据\nfor row in reader:\n    print(row)\n\nfile.close()\n```\n\n# 数据写入内存\n\n## StringIO\n\nStringIO可以将字符串写入到内存中，像操作文件一下操作字符串。\n\n```python\nfrom io import StringIO\n\n# 创建一个StringIO对象\nf = StringIO()\n# 可以像操作文件一下，将字符串写入到内存中\nf.write('hello\\r\\n')\nf.write('good')\n\n# 使用文件的 readline和readlines方法，无法读取到数据\n# print(f.readline())\n# print(f.readlines())\n\n# 需要调用getvalue()方法才能获取到写入到内存中的数据\nprint(f.getvalue())\n\nf.close()\n```\n\n## BytesIO\n\n如果想要以二进制的形式写入数据，可以使用BytesIO类，它的用法和StringIO相似，只不过在调用write方法写入时，**需要传入二进制数据**。\n\n```python\nfrom io import BytesIO\n\nf = BytesIO()\nf.write('你好\\r\\n'.encode('utf-8'))\nf.write('中国'.encode('utf-8'))\n\nprint(f.getvalue())\nf.close()\n```\n\n# 序列化和反序列化\n\n将对象序列化之后才能写入文件，也可以将文件中的字节（字符）反序列化为python对象（列表、字典、元组。。。）\n\n## JSON模块序列化\n\nJSON(JavaScriptObjectNotation, JS对象简谱)是一种轻量级的数据交换格式，它基于 ECMAScript 的一个子集，采用完全独立于编程语言的**文本格式**来存储和表示数据。**JSON的本质是字符串**！\n\n### dump/dumps方法实现序列化\n\ndumps方法可以将对象转化为字符串，并不具备写入文件的功能\n\n```python\nimport json\n\nfile = open('text.txt', 'w')\n\nnames = ['zhangsan', 'lisi', 'wangwu', 'merry', 'jack']\n# file.write(names)    出错，不能直接将列表写入文件中\n\n# 调用json的dumps方法，传入对象，返回json字符串\njson_result = json.dumps(names)\n\nprint(type(json_result))    # <class 'str'>\n\nfile.write(json_result)\n\nfile.close()\n```\n\ndump方法可以在将对象转换成为字符串的同时，指定一个文件对象，把转换后的字符串写入到这个文件里。\n\n```python\nimport json\n\nfile = open('names.txt', 'w')\nnames = ['zhangsan', 'lisi', 'wangwu', 'jerry', 'henry', 'merry', 'chris']\n\n# dump方法可以接收一个文件参数，在将对象转换成为字符串的同时写入到文件里\njson.dump(names, file)\nfile.close()\n```\n\n注意：如果是一个空对象，调用dumps方法转换成为一个JSON对象，得到的结果是null(JS里的空对象)\n\n### load/loads方法实现反序列化\n\nloads方法需要一个字符串参数，用来将一个字符串加载成为Python对象。\n\n```python\nimport json\n\n# 调用loads方法，传入一个字符串，可以将这个字符串加载成为Python对象\nresult = json.loads('[\"zhangsan\", \"lisi\", \"wangwu\", \"jerry\", \"henry\", \"merry\", \"chris\"]')\nprint(type(result))  # <class 'list'>\nCopy\n```\n\nload方法可以传入一个文件对象，用来将一个文件对象里的数据加载成为Python对象。\n\n```python\nimport json\n\n# 以可读方式打开一个文件\nfile = open('names.txt', 'r')\n\n# 调用load方法，将文件里的内容加载成为一个Python对象\nresult = json.load(file)\n\nprint(result)\nfile.close()\n```\n\n## pickle模块序列化\n\n和json模块类似，pickle模块也有dump和dumps方法可以对数据进行序列化，同时也有load和loads方法进行反序列化。区别在于，json模块是将对象转换成为字符串，而pickle模块是将对象转换成为二进制。\n\npickle模块里方法的使用和json里方法的使用大致相同，需要注意的是，**pickle是将对象转换成为二进制，所以，如果想要把内容写入到文件里，这个文件必须要以二进制的形式打开。**\n\n## json和pickle的区别\n\n- json模块:\n\n  - 将对象转化为字符串，而字符串在任何系统和编程语言中都是可以识别的；\n  - json的用处就是跨平台信息传输；\n  - python对象与json字符串对应关系：\n\n  | Python     | JSON   |\n  | ---------- | ------ |\n  | dict       | object |\n  | list,tuple | array  |\n  | str        | string |\n  | int,float  | number |\n  | True       | true   |\n  | False      | false  |\n  | None       | null   |\n\n- 如果是一个自定义对象，默认无法装换成为json字符串，需要手动指定JSONEncoder.\n\n- 如果是将一个json串重新转换成为对象，这个对象里的方法就无法使用了。\n\n  ```python\n  import json\n  class MyEncode(json.JSONEncoder):\n      def default(self, o):\n          # return {\"name\":o.name,\"age\":o.age}\n          return o.__dict__\n  \n  class Person(object):\n      def __init__(self, name, age):\n          self.name = name\n          self.age = age\n  \n        def eat(self):\n            print(self.name+'正在吃东西')\n  \n  p1 = Person('zhangsan', 18)\n  \n  # 自定义对象想要转换成为json字符串，需要给这个自定义对象指定JSONEncoder\n  result = json.dumps(p1, cls=MyEncode)\n  print(result)  # {\"name\": \"zhangsan\", \"age\": 18}\n  \n  # 调用loads方法将对象加载成为一个对象以后，得到的结果是一个字典\n  p = json.loads(result)\n  print(type(p))\n  Copy\n  ```\n\n- pickle模块：\n  - pickle序列化是将对象按照一定的规则转换成为二进制保存，它不能跨平台传递数据。\n  - pickle的序列化会将对象的所有数据都保存。\n  - pickle适合对需要使用的自定义对象进行序列化处理\n  - 深拷贝也可以使用pickle实现\n\n# 使用with关键字\n\nwith语句实质上是一个上下文管理器，with语句后的对象都会有`__enter__()`和`__exit__()`方法。在进入到上下文时，会自动调用`__enter__()`方法，程序正常执行完成，或者出现异常中断的时候，都会调用`__exit__()`方法。\n\n```python\ndef m3():\n    with open(\"output.txt\", \"r\") as f:\n        f.write(\"Python之禅\")\n```\n\nopen 方法的返回值赋值给变量 f，当离开 with 代码块的时候，系统会自动调用 f.close() 方法。\n\n## 上下文管理器\n\n```python\nclass MyContext(object):\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n\n    def __enter__(self):\n        print('调用了enter方法')\n        return self\n\n    def test(self):\n        1 / 0\n        print(self.name + '调用了test方法')\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        print('调用了exit方法')\n        print(exc_type, exc_val, exc_tb)\n\nwith MyContext('zhangsan', 18) as context:\n    context.test()\n```\n","slug":"文件操作","published":1,"updated":"2021-02-02T01:56:02.878Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckknh5t9t00033ntyako23dva","content":"<h1 id=\"文件操作\"><a href=\"#文件操作\" class=\"headerlink\" title=\"文件操作\"></a>文件操作</h1><p>关于在Python中对文件相关操作的记录</p>\n<a id=\"more\"></a>\n\n<h1 id=\"文件的打开\"><a href=\"#文件的打开\" class=\"headerlink\" title=\"文件的打开\"></a>文件的打开</h1><p>在python中可以使用open函数打开一个已经存在的文件，或者创建一个新文件。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">file = open(<span class=\"string\">&#x27;../a.txt&#x27;</span>, <span class=\"string\">&#x27;w&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"访问模式\"><a href=\"#访问模式\" class=\"headerlink\" title=\"访问模式\"></a>访问模式</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">open(file, mode=<span class=\"string\">&#x27;r&#x27;</span>, buffering=<span class=\"literal\">None</span>, encoding=<span class=\"literal\">None</span>, errors=<span class=\"literal\">None</span>, newline=<span class=\"literal\">None</span>, closefd=<span class=\"literal\">True</span>)</span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th align=\"center\">访问模式</th>\n<th align=\"left\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">r</td>\n<td align=\"left\">只读——已存在则从头开始——不存在则报错——读完不重新open文件指针不会复原<br />这是默认模式。**</td>\n</tr>\n<tr>\n<td align=\"center\">w</td>\n<td align=\"left\">只写——已存在则覆写——不存在则创建新文件——同一次文件指针不会复原（等同于追加）——重新open就会覆写</td>\n</tr>\n<tr>\n<td align=\"center\">a</td>\n<td align=\"left\">追加——已存在则追加原内容之后——不存在则创建新文件——只写不读</td>\n</tr>\n<tr>\n<td align=\"center\">r+</td>\n<td align=\"left\">读写——文件指针默认在文件开始位置，写入会覆盖相同长度的原内容——操作之后文件指针不会复原</td>\n</tr>\n<tr>\n<td align=\"center\">w+</td>\n<td align=\"left\">读写——文件已存在则将其覆盖——文件不存在则创建新文件——每次open都是清空原内容，但是写入操作之后文件指针在文件末，此时读会为空，需要重置指针</td>\n</tr>\n<tr>\n<td align=\"center\">a+</td>\n<td align=\"left\">追加方式读写——文件已存在，文件指针将会放在文件的结尾，可以直接追加，所以读为空——文件不存在，创建新文件用于读写</td>\n</tr>\n<tr>\n<td align=\"center\">b</td>\n<td align=\"left\">二进制格式操作</td>\n</tr>\n<tr>\n<td align=\"center\">t</td>\n<td align=\"left\">文本模式</td>\n</tr>\n<tr>\n<td align=\"center\">U</td>\n<td align=\"left\">通用换行符，将所有的\\n、\\r 都替换成 \\n<br />（universal newline mode (deprecated)）</td>\n</tr>\n<tr>\n<td align=\"center\">buffering</td>\n<td align=\"left\">为了减少I/O操作，使用缓冲区，达到要求的数据量才进行系统调用<br />全缓冲：buffering=1024        设置大于1的整数表示缓冲区大小<br />行缓冲：buffering=1        按行缓冲，适用于文本内容<br />无缓冲：buffering=0        来一个处理一个，只适用于二进制模式</td>\n</tr>\n<tr>\n<td align=\"center\">encoding</td>\n<td align=\"left\">返回数据采用何种编码方式进行解码——‘utf-8’、‘gbk’</td>\n</tr>\n<tr>\n<td align=\"center\">errors</td>\n<td align=\"left\">取值一般有strict，ignore，当取strict的时候，字符编码出现问题的时候，会报错，当取ignore的时候，编码出现问题，程序会忽略而过，继续执行下面的程序</td>\n</tr>\n<tr>\n<td align=\"center\">newline</td>\n<td align=\"left\">可以取的值有None, \\n, \\r, ”, ‘\\r\\n’，用于区分换行符，但是这个参数只对文本模式有效</td>\n</tr>\n<tr>\n<td align=\"center\">文件指针操作</td>\n<td align=\"left\">file.tell    查看指针当前位置<br />file.seek(0)    将指针移到文件开头</td>\n</tr>\n</tbody></table>\n<h1 id=\"文件关闭\"><a href=\"#文件关闭\" class=\"headerlink\" title=\"文件关闭\"></a>文件关闭</h1><p>文件打开之后一定要关闭</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">file.close()</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"文件的读写\"><a href=\"#文件的读写\" class=\"headerlink\" title=\"文件的读写\"></a>文件的读写</h1><h2 id=\"写数据\"><a href=\"#写数据\" class=\"headerlink\" title=\"写数据\"></a>写数据</h2><p>使用 write() 向文件写数据</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">file.open(<span class=\"string\">&#x27;test.txt&#x27;</span>, <span class=\"string\">&#x27;w&#x27;</span>)</span><br><span class=\"line\">file.write(<span class=\"string\">&#x27;hello world, i am here!\\n&#x27;</span> * <span class=\"number\">5</span>)</span><br><span class=\"line\">file.close()</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"读数据\"><a href=\"#读数据\" class=\"headerlink\" title=\"读数据\"></a>读数据</h2><p>使用read(num)可以从文件中读取数据，num表示读取的数据长度，单位是字节。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">one_k = file.read(<span class=\"number\">1024</span>)</span><br><span class=\"line\">print(one_k)</span><br><span class=\"line\"><span class=\"comment\"># 同一次open内不会还原文件指针位置</span></span><br><span class=\"line\"><span class=\"comment\"># 会读取接下来的所有内容</span></span><br><span class=\"line\">last = file.read()</span><br><span class=\"line\">print(last)</span><br></pre></td></tr></table></figure>\n\n<p>使用readlines() 可以按照行的方式将整个文件的内容进行一次性读取，返回一个列表，每一行为列表的一个元素。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">content = f.readlines()</span><br><span class=\"line\">print(type(content))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> temp <span class=\"keyword\">in</span> content:</span><br><span class=\"line\">    print(temp)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"重置指针位置\"><a href=\"#重置指针位置\" class=\"headerlink\" title=\"重置指针位置\"></a>重置指针位置</h2><p>seek(offset, whence) 方法重置文件指针的位置</p>\n<ul>\n<li>offset：表示偏移量</li>\n<li>whence：表示指针移动位置，只能传入0、1、2<ul>\n<li>0表示从文件头开始</li>\n<li>1表示从当前位置开始，配合偏移量使用</li>\n<li>2表示从文件末尾开始</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f.seek(<span class=\"number\">2</span>,<span class=\"number\">0</span>)   <span class=\"comment\"># 从文件的开头开始，跳过两个字节</span></span><br><span class=\"line\">print(f.read())</span><br><span class=\"line\"></span><br><span class=\"line\">f.seek(<span class=\"number\">1</span>,<span class=\"number\">1</span>) <span class=\"comment\"># 从当前位置开始，跳过一个字节</span></span><br><span class=\"line\">print(f.read())</span><br><span class=\"line\"></span><br><span class=\"line\">f.seek(<span class=\"number\">-4</span>,<span class=\"number\">2</span>) <span class=\"comment\"># 从文件末尾开始，往前跳过四个字节</span></span><br><span class=\"line\">print(f.read())</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"CSV文件\"><a href=\"#CSV文件\" class=\"headerlink\" title=\"CSV文件\"></a>CSV文件</h1><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> csv</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 先以写入模式打开一个csv文件</span></span><br><span class=\"line\">csvfile = open(<span class=\"string\">&#x27;tst.csv&#x27;</span>, <span class=\"string\">&#x27;w&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># csv的writer方法将文件对象变成CSVWriter对象</span></span><br><span class=\"line\">csvwriter = csv.writer(file)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 调用CSVWriter的writerow方法可以按行写入数据</span></span><br><span class=\"line\">csvwrite.writerow([<span class=\"string\">&#x27;name&#x27;</span>, <span class=\"string\">&#x27;age&#x27;</span>, <span class=\"string\">&#x27;score&#x27;</span>])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># writerows方法可以一次性写入多行</span></span><br><span class=\"line\">csvwriter.writerows([<span class=\"string\">&#x27;zhangsan&#x27;</span>, <span class=\"string\">&#x27;18&#x27;</span>, <span class=\"string\">&#x27;98&#x27;</span>], [<span class=\"string\">&#x27;lisi&#x27;</span>, <span class=\"string\">&#x27;19&#x27;</span>, <span class=\"string\">&#x27;99&#x27;</span>], [<span class=\"string\">&#x27;wangwu&#x27;</span>, <span class=\"string\">&#x27;18&#x27;</span>, <span class=\"string\">&#x27;97&#x27;</span>])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 调用csv模块的reader方法，得到的结果是一个可迭代对象</span></span><br><span class=\"line\">reader = csv.reader(file)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 对结果进行遍历，获取到结果里的每一行数据</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> row <span class=\"keyword\">in</span> reader:</span><br><span class=\"line\">    print(row)</span><br><span class=\"line\"></span><br><span class=\"line\">file.close()</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"数据写入内存\"><a href=\"#数据写入内存\" class=\"headerlink\" title=\"数据写入内存\"></a>数据写入内存</h1><h2 id=\"StringIO\"><a href=\"#StringIO\" class=\"headerlink\" title=\"StringIO\"></a>StringIO</h2><p>StringIO可以将字符串写入到内存中，像操作文件一下操作字符串。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> io <span class=\"keyword\">import</span> StringIO</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建一个StringIO对象</span></span><br><span class=\"line\">f = StringIO()</span><br><span class=\"line\"><span class=\"comment\"># 可以像操作文件一下，将字符串写入到内存中</span></span><br><span class=\"line\">f.write(<span class=\"string\">&#x27;hello\\r\\n&#x27;</span>)</span><br><span class=\"line\">f.write(<span class=\"string\">&#x27;good&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 使用文件的 readline和readlines方法，无法读取到数据</span></span><br><span class=\"line\"><span class=\"comment\"># print(f.readline())</span></span><br><span class=\"line\"><span class=\"comment\"># print(f.readlines())</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 需要调用getvalue()方法才能获取到写入到内存中的数据</span></span><br><span class=\"line\">print(f.getvalue())</span><br><span class=\"line\"></span><br><span class=\"line\">f.close()</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"BytesIO\"><a href=\"#BytesIO\" class=\"headerlink\" title=\"BytesIO\"></a>BytesIO</h2><p>如果想要以二进制的形式写入数据，可以使用BytesIO类，它的用法和StringIO相似，只不过在调用write方法写入时，<strong>需要传入二进制数据</strong>。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> io <span class=\"keyword\">import</span> BytesIO</span><br><span class=\"line\"></span><br><span class=\"line\">f = BytesIO()</span><br><span class=\"line\">f.write(<span class=\"string\">&#x27;你好\\r\\n&#x27;</span>.encode(<span class=\"string\">&#x27;utf-8&#x27;</span>))</span><br><span class=\"line\">f.write(<span class=\"string\">&#x27;中国&#x27;</span>.encode(<span class=\"string\">&#x27;utf-8&#x27;</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">print(f.getvalue())</span><br><span class=\"line\">f.close()</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"序列化和反序列化\"><a href=\"#序列化和反序列化\" class=\"headerlink\" title=\"序列化和反序列化\"></a>序列化和反序列化</h1><p>将对象序列化之后才能写入文件，也可以将文件中的字节（字符）反序列化为python对象（列表、字典、元组。。。）</p>\n<h2 id=\"JSON模块序列化\"><a href=\"#JSON模块序列化\" class=\"headerlink\" title=\"JSON模块序列化\"></a>JSON模块序列化</h2><p>JSON(JavaScriptObjectNotation, JS对象简谱)是一种轻量级的数据交换格式，它基于 ECMAScript 的一个子集，采用完全独立于编程语言的<strong>文本格式</strong>来存储和表示数据。<strong>JSON的本质是字符串</strong>！</p>\n<h3 id=\"dump-dumps方法实现序列化\"><a href=\"#dump-dumps方法实现序列化\" class=\"headerlink\" title=\"dump/dumps方法实现序列化\"></a>dump/dumps方法实现序列化</h3><p>dumps方法可以将对象转化为字符串，并不具备写入文件的功能</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> json</span><br><span class=\"line\"></span><br><span class=\"line\">file = open(<span class=\"string\">&#x27;text.txt&#x27;</span>, <span class=\"string\">&#x27;w&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">names = [<span class=\"string\">&#x27;zhangsan&#x27;</span>, <span class=\"string\">&#x27;lisi&#x27;</span>, <span class=\"string\">&#x27;wangwu&#x27;</span>, <span class=\"string\">&#x27;merry&#x27;</span>, <span class=\"string\">&#x27;jack&#x27;</span>]</span><br><span class=\"line\"><span class=\"comment\"># file.write(names)    出错，不能直接将列表写入文件中</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 调用json的dumps方法，传入对象，返回json字符串</span></span><br><span class=\"line\">json_result = json.dumps(names)</span><br><span class=\"line\"></span><br><span class=\"line\">print(type(json_result))    <span class=\"comment\"># &lt;class &#x27;str&#x27;&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">file.write(json_result)</span><br><span class=\"line\"></span><br><span class=\"line\">file.close()</span><br></pre></td></tr></table></figure>\n\n<p>dump方法可以在将对象转换成为字符串的同时，指定一个文件对象，把转换后的字符串写入到这个文件里。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> json</span><br><span class=\"line\"></span><br><span class=\"line\">file = open(<span class=\"string\">&#x27;names.txt&#x27;</span>, <span class=\"string\">&#x27;w&#x27;</span>)</span><br><span class=\"line\">names = [<span class=\"string\">&#x27;zhangsan&#x27;</span>, <span class=\"string\">&#x27;lisi&#x27;</span>, <span class=\"string\">&#x27;wangwu&#x27;</span>, <span class=\"string\">&#x27;jerry&#x27;</span>, <span class=\"string\">&#x27;henry&#x27;</span>, <span class=\"string\">&#x27;merry&#x27;</span>, <span class=\"string\">&#x27;chris&#x27;</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># dump方法可以接收一个文件参数，在将对象转换成为字符串的同时写入到文件里</span></span><br><span class=\"line\">json.dump(names, file)</span><br><span class=\"line\">file.close()</span><br></pre></td></tr></table></figure>\n\n<p>注意：如果是一个空对象，调用dumps方法转换成为一个JSON对象，得到的结果是null(JS里的空对象)</p>\n<h3 id=\"load-loads方法实现反序列化\"><a href=\"#load-loads方法实现反序列化\" class=\"headerlink\" title=\"load/loads方法实现反序列化\"></a>load/loads方法实现反序列化</h3><p>loads方法需要一个字符串参数，用来将一个字符串加载成为Python对象。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> json</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 调用loads方法，传入一个字符串，可以将这个字符串加载成为Python对象</span></span><br><span class=\"line\">result = json.loads(<span class=\"string\">&#x27;[&quot;zhangsan&quot;, &quot;lisi&quot;, &quot;wangwu&quot;, &quot;jerry&quot;, &quot;henry&quot;, &quot;merry&quot;, &quot;chris&quot;]&#x27;</span>)</span><br><span class=\"line\">print(type(result))  <span class=\"comment\"># &lt;class &#x27;list&#x27;&gt;</span></span><br><span class=\"line\">Copy</span><br></pre></td></tr></table></figure>\n\n<p>load方法可以传入一个文件对象，用来将一个文件对象里的数据加载成为Python对象。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> json</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 以可读方式打开一个文件</span></span><br><span class=\"line\">file = open(<span class=\"string\">&#x27;names.txt&#x27;</span>, <span class=\"string\">&#x27;r&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 调用load方法，将文件里的内容加载成为一个Python对象</span></span><br><span class=\"line\">result = json.load(file)</span><br><span class=\"line\"></span><br><span class=\"line\">print(result)</span><br><span class=\"line\">file.close()</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"pickle模块序列化\"><a href=\"#pickle模块序列化\" class=\"headerlink\" title=\"pickle模块序列化\"></a>pickle模块序列化</h2><p>和json模块类似，pickle模块也有dump和dumps方法可以对数据进行序列化，同时也有load和loads方法进行反序列化。区别在于，json模块是将对象转换成为字符串，而pickle模块是将对象转换成为二进制。</p>\n<p>pickle模块里方法的使用和json里方法的使用大致相同，需要注意的是，<strong>pickle是将对象转换成为二进制，所以，如果想要把内容写入到文件里，这个文件必须要以二进制的形式打开。</strong></p>\n<h2 id=\"json和pickle的区别\"><a href=\"#json和pickle的区别\" class=\"headerlink\" title=\"json和pickle的区别\"></a>json和pickle的区别</h2><ul>\n<li><p>json模块:</p>\n<ul>\n<li>将对象转化为字符串，而字符串在任何系统和编程语言中都是可以识别的；</li>\n<li>json的用处就是跨平台信息传输；</li>\n<li>python对象与json字符串对应关系：</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>Python</th>\n<th>JSON</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>dict</td>\n<td>object</td>\n</tr>\n<tr>\n<td>list,tuple</td>\n<td>array</td>\n</tr>\n<tr>\n<td>str</td>\n<td>string</td>\n</tr>\n<tr>\n<td>int,float</td>\n<td>number</td>\n</tr>\n<tr>\n<td>True</td>\n<td>true</td>\n</tr>\n<tr>\n<td>False</td>\n<td>false</td>\n</tr>\n<tr>\n<td>None</td>\n<td>null</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>如果是一个自定义对象，默认无法装换成为json字符串，需要手动指定JSONEncoder.</p>\n</li>\n<li><p>如果是将一个json串重新转换成为对象，这个对象里的方法就无法使用了。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> json</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyEncode</span>(<span class=\"params\">json.JSONEncoder</span>):</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">default</span>(<span class=\"params\">self, o</span>):</span></span><br><span class=\"line\">        <span class=\"comment\"># return &#123;&quot;name&quot;:o.name,&quot;age&quot;:o.age&#125;</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> o.__dict__</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span>(<span class=\"params\">object</span>):</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self, name, age</span>):</span></span><br><span class=\"line\">        self.name = name</span><br><span class=\"line\">        self.age = age</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">eat</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">          print(self.name+<span class=\"string\">&#x27;正在吃东西&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">p1 = Person(<span class=\"string\">&#x27;zhangsan&#x27;</span>, <span class=\"number\">18</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 自定义对象想要转换成为json字符串，需要给这个自定义对象指定JSONEncoder</span></span><br><span class=\"line\">result = json.dumps(p1, cls=MyEncode)</span><br><span class=\"line\">print(result)  <span class=\"comment\"># &#123;&quot;name&quot;: &quot;zhangsan&quot;, &quot;age&quot;: 18&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 调用loads方法将对象加载成为一个对象以后，得到的结果是一个字典</span></span><br><span class=\"line\">p = json.loads(result)</span><br><span class=\"line\">print(type(p))</span><br><span class=\"line\">Copy</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>pickle模块：</p>\n<ul>\n<li>pickle序列化是将对象按照一定的规则转换成为二进制保存，它不能跨平台传递数据。</li>\n<li>pickle的序列化会将对象的所有数据都保存。</li>\n<li>pickle适合对需要使用的自定义对象进行序列化处理</li>\n<li>深拷贝也可以使用pickle实现</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"使用with关键字\"><a href=\"#使用with关键字\" class=\"headerlink\" title=\"使用with关键字\"></a>使用with关键字</h1><p>with语句实质上是一个上下文管理器，with语句后的对象都会有<code>__enter__()</code>和<code>__exit__()</code>方法。在进入到上下文时，会自动调用<code>__enter__()</code>方法，程序正常执行完成，或者出现异常中断的时候，都会调用<code>__exit__()</code>方法。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">m3</span>():</span></span><br><span class=\"line\">    <span class=\"keyword\">with</span> open(<span class=\"string\">&quot;output.txt&quot;</span>, <span class=\"string\">&quot;r&quot;</span>) <span class=\"keyword\">as</span> f:</span><br><span class=\"line\">        f.write(<span class=\"string\">&quot;Python之禅&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>open 方法的返回值赋值给变量 f，当离开 with 代码块的时候，系统会自动调用 f.close() 方法。</p>\n<h2 id=\"上下文管理器\"><a href=\"#上下文管理器\" class=\"headerlink\" title=\"上下文管理器\"></a>上下文管理器</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyContext</span>(<span class=\"params\">object</span>):</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self, name, age</span>):</span></span><br><span class=\"line\">        self.name = name</span><br><span class=\"line\">        self.age = age</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__enter__</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        print(<span class=\"string\">&#x27;调用了enter方法&#x27;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> self</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">test</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        <span class=\"number\">1</span> / <span class=\"number\">0</span></span><br><span class=\"line\">        print(self.name + <span class=\"string\">&#x27;调用了test方法&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__exit__</span>(<span class=\"params\">self, exc_type, exc_val, exc_tb</span>):</span></span><br><span class=\"line\">        print(<span class=\"string\">&#x27;调用了exit方法&#x27;</span>)</span><br><span class=\"line\">        print(exc_type, exc_val, exc_tb)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">with</span> MyContext(<span class=\"string\">&#x27;zhangsan&#x27;</span>, <span class=\"number\">18</span>) <span class=\"keyword\">as</span> context:</span><br><span class=\"line\">    context.test()</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h1 id=\"文件操作\"><a href=\"#文件操作\" class=\"headerlink\" title=\"文件操作\"></a>文件操作</h1><p>关于在Python中对文件相关操作的记录</p>","more":"<h1 id=\"文件的打开\"><a href=\"#文件的打开\" class=\"headerlink\" title=\"文件的打开\"></a>文件的打开</h1><p>在python中可以使用open函数打开一个已经存在的文件，或者创建一个新文件。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">file = open(<span class=\"string\">&#x27;../a.txt&#x27;</span>, <span class=\"string\">&#x27;w&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"访问模式\"><a href=\"#访问模式\" class=\"headerlink\" title=\"访问模式\"></a>访问模式</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">open(file, mode=<span class=\"string\">&#x27;r&#x27;</span>, buffering=<span class=\"literal\">None</span>, encoding=<span class=\"literal\">None</span>, errors=<span class=\"literal\">None</span>, newline=<span class=\"literal\">None</span>, closefd=<span class=\"literal\">True</span>)</span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th align=\"center\">访问模式</th>\n<th align=\"left\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">r</td>\n<td align=\"left\">只读——已存在则从头开始——不存在则报错——读完不重新open文件指针不会复原<br />这是默认模式。**</td>\n</tr>\n<tr>\n<td align=\"center\">w</td>\n<td align=\"left\">只写——已存在则覆写——不存在则创建新文件——同一次文件指针不会复原（等同于追加）——重新open就会覆写</td>\n</tr>\n<tr>\n<td align=\"center\">a</td>\n<td align=\"left\">追加——已存在则追加原内容之后——不存在则创建新文件——只写不读</td>\n</tr>\n<tr>\n<td align=\"center\">r+</td>\n<td align=\"left\">读写——文件指针默认在文件开始位置，写入会覆盖相同长度的原内容——操作之后文件指针不会复原</td>\n</tr>\n<tr>\n<td align=\"center\">w+</td>\n<td align=\"left\">读写——文件已存在则将其覆盖——文件不存在则创建新文件——每次open都是清空原内容，但是写入操作之后文件指针在文件末，此时读会为空，需要重置指针</td>\n</tr>\n<tr>\n<td align=\"center\">a+</td>\n<td align=\"left\">追加方式读写——文件已存在，文件指针将会放在文件的结尾，可以直接追加，所以读为空——文件不存在，创建新文件用于读写</td>\n</tr>\n<tr>\n<td align=\"center\">b</td>\n<td align=\"left\">二进制格式操作</td>\n</tr>\n<tr>\n<td align=\"center\">t</td>\n<td align=\"left\">文本模式</td>\n</tr>\n<tr>\n<td align=\"center\">U</td>\n<td align=\"left\">通用换行符，将所有的\\n、\\r 都替换成 \\n<br />（universal newline mode (deprecated)）</td>\n</tr>\n<tr>\n<td align=\"center\">buffering</td>\n<td align=\"left\">为了减少I/O操作，使用缓冲区，达到要求的数据量才进行系统调用<br />全缓冲：buffering=1024        设置大于1的整数表示缓冲区大小<br />行缓冲：buffering=1        按行缓冲，适用于文本内容<br />无缓冲：buffering=0        来一个处理一个，只适用于二进制模式</td>\n</tr>\n<tr>\n<td align=\"center\">encoding</td>\n<td align=\"left\">返回数据采用何种编码方式进行解码——‘utf-8’、‘gbk’</td>\n</tr>\n<tr>\n<td align=\"center\">errors</td>\n<td align=\"left\">取值一般有strict，ignore，当取strict的时候，字符编码出现问题的时候，会报错，当取ignore的时候，编码出现问题，程序会忽略而过，继续执行下面的程序</td>\n</tr>\n<tr>\n<td align=\"center\">newline</td>\n<td align=\"left\">可以取的值有None, \\n, \\r, ”, ‘\\r\\n’，用于区分换行符，但是这个参数只对文本模式有效</td>\n</tr>\n<tr>\n<td align=\"center\">文件指针操作</td>\n<td align=\"left\">file.tell    查看指针当前位置<br />file.seek(0)    将指针移到文件开头</td>\n</tr>\n</tbody></table>\n<h1 id=\"文件关闭\"><a href=\"#文件关闭\" class=\"headerlink\" title=\"文件关闭\"></a>文件关闭</h1><p>文件打开之后一定要关闭</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">file.close()</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"文件的读写\"><a href=\"#文件的读写\" class=\"headerlink\" title=\"文件的读写\"></a>文件的读写</h1><h2 id=\"写数据\"><a href=\"#写数据\" class=\"headerlink\" title=\"写数据\"></a>写数据</h2><p>使用 write() 向文件写数据</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">file.open(<span class=\"string\">&#x27;test.txt&#x27;</span>, <span class=\"string\">&#x27;w&#x27;</span>)</span><br><span class=\"line\">file.write(<span class=\"string\">&#x27;hello world, i am here!\\n&#x27;</span> * <span class=\"number\">5</span>)</span><br><span class=\"line\">file.close()</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"读数据\"><a href=\"#读数据\" class=\"headerlink\" title=\"读数据\"></a>读数据</h2><p>使用read(num)可以从文件中读取数据，num表示读取的数据长度，单位是字节。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">one_k = file.read(<span class=\"number\">1024</span>)</span><br><span class=\"line\">print(one_k)</span><br><span class=\"line\"><span class=\"comment\"># 同一次open内不会还原文件指针位置</span></span><br><span class=\"line\"><span class=\"comment\"># 会读取接下来的所有内容</span></span><br><span class=\"line\">last = file.read()</span><br><span class=\"line\">print(last)</span><br></pre></td></tr></table></figure>\n\n<p>使用readlines() 可以按照行的方式将整个文件的内容进行一次性读取，返回一个列表，每一行为列表的一个元素。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">content = f.readlines()</span><br><span class=\"line\">print(type(content))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> temp <span class=\"keyword\">in</span> content:</span><br><span class=\"line\">    print(temp)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"重置指针位置\"><a href=\"#重置指针位置\" class=\"headerlink\" title=\"重置指针位置\"></a>重置指针位置</h2><p>seek(offset, whence) 方法重置文件指针的位置</p>\n<ul>\n<li>offset：表示偏移量</li>\n<li>whence：表示指针移动位置，只能传入0、1、2<ul>\n<li>0表示从文件头开始</li>\n<li>1表示从当前位置开始，配合偏移量使用</li>\n<li>2表示从文件末尾开始</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f.seek(<span class=\"number\">2</span>,<span class=\"number\">0</span>)   <span class=\"comment\"># 从文件的开头开始，跳过两个字节</span></span><br><span class=\"line\">print(f.read())</span><br><span class=\"line\"></span><br><span class=\"line\">f.seek(<span class=\"number\">1</span>,<span class=\"number\">1</span>) <span class=\"comment\"># 从当前位置开始，跳过一个字节</span></span><br><span class=\"line\">print(f.read())</span><br><span class=\"line\"></span><br><span class=\"line\">f.seek(<span class=\"number\">-4</span>,<span class=\"number\">2</span>) <span class=\"comment\"># 从文件末尾开始，往前跳过四个字节</span></span><br><span class=\"line\">print(f.read())</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"CSV文件\"><a href=\"#CSV文件\" class=\"headerlink\" title=\"CSV文件\"></a>CSV文件</h1><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> csv</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 先以写入模式打开一个csv文件</span></span><br><span class=\"line\">csvfile = open(<span class=\"string\">&#x27;tst.csv&#x27;</span>, <span class=\"string\">&#x27;w&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># csv的writer方法将文件对象变成CSVWriter对象</span></span><br><span class=\"line\">csvwriter = csv.writer(file)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 调用CSVWriter的writerow方法可以按行写入数据</span></span><br><span class=\"line\">csvwrite.writerow([<span class=\"string\">&#x27;name&#x27;</span>, <span class=\"string\">&#x27;age&#x27;</span>, <span class=\"string\">&#x27;score&#x27;</span>])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># writerows方法可以一次性写入多行</span></span><br><span class=\"line\">csvwriter.writerows([<span class=\"string\">&#x27;zhangsan&#x27;</span>, <span class=\"string\">&#x27;18&#x27;</span>, <span class=\"string\">&#x27;98&#x27;</span>], [<span class=\"string\">&#x27;lisi&#x27;</span>, <span class=\"string\">&#x27;19&#x27;</span>, <span class=\"string\">&#x27;99&#x27;</span>], [<span class=\"string\">&#x27;wangwu&#x27;</span>, <span class=\"string\">&#x27;18&#x27;</span>, <span class=\"string\">&#x27;97&#x27;</span>])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 调用csv模块的reader方法，得到的结果是一个可迭代对象</span></span><br><span class=\"line\">reader = csv.reader(file)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 对结果进行遍历，获取到结果里的每一行数据</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> row <span class=\"keyword\">in</span> reader:</span><br><span class=\"line\">    print(row)</span><br><span class=\"line\"></span><br><span class=\"line\">file.close()</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"数据写入内存\"><a href=\"#数据写入内存\" class=\"headerlink\" title=\"数据写入内存\"></a>数据写入内存</h1><h2 id=\"StringIO\"><a href=\"#StringIO\" class=\"headerlink\" title=\"StringIO\"></a>StringIO</h2><p>StringIO可以将字符串写入到内存中，像操作文件一下操作字符串。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> io <span class=\"keyword\">import</span> StringIO</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建一个StringIO对象</span></span><br><span class=\"line\">f = StringIO()</span><br><span class=\"line\"><span class=\"comment\"># 可以像操作文件一下，将字符串写入到内存中</span></span><br><span class=\"line\">f.write(<span class=\"string\">&#x27;hello\\r\\n&#x27;</span>)</span><br><span class=\"line\">f.write(<span class=\"string\">&#x27;good&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 使用文件的 readline和readlines方法，无法读取到数据</span></span><br><span class=\"line\"><span class=\"comment\"># print(f.readline())</span></span><br><span class=\"line\"><span class=\"comment\"># print(f.readlines())</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 需要调用getvalue()方法才能获取到写入到内存中的数据</span></span><br><span class=\"line\">print(f.getvalue())</span><br><span class=\"line\"></span><br><span class=\"line\">f.close()</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"BytesIO\"><a href=\"#BytesIO\" class=\"headerlink\" title=\"BytesIO\"></a>BytesIO</h2><p>如果想要以二进制的形式写入数据，可以使用BytesIO类，它的用法和StringIO相似，只不过在调用write方法写入时，<strong>需要传入二进制数据</strong>。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> io <span class=\"keyword\">import</span> BytesIO</span><br><span class=\"line\"></span><br><span class=\"line\">f = BytesIO()</span><br><span class=\"line\">f.write(<span class=\"string\">&#x27;你好\\r\\n&#x27;</span>.encode(<span class=\"string\">&#x27;utf-8&#x27;</span>))</span><br><span class=\"line\">f.write(<span class=\"string\">&#x27;中国&#x27;</span>.encode(<span class=\"string\">&#x27;utf-8&#x27;</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">print(f.getvalue())</span><br><span class=\"line\">f.close()</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"序列化和反序列化\"><a href=\"#序列化和反序列化\" class=\"headerlink\" title=\"序列化和反序列化\"></a>序列化和反序列化</h1><p>将对象序列化之后才能写入文件，也可以将文件中的字节（字符）反序列化为python对象（列表、字典、元组。。。）</p>\n<h2 id=\"JSON模块序列化\"><a href=\"#JSON模块序列化\" class=\"headerlink\" title=\"JSON模块序列化\"></a>JSON模块序列化</h2><p>JSON(JavaScriptObjectNotation, JS对象简谱)是一种轻量级的数据交换格式，它基于 ECMAScript 的一个子集，采用完全独立于编程语言的<strong>文本格式</strong>来存储和表示数据。<strong>JSON的本质是字符串</strong>！</p>\n<h3 id=\"dump-dumps方法实现序列化\"><a href=\"#dump-dumps方法实现序列化\" class=\"headerlink\" title=\"dump/dumps方法实现序列化\"></a>dump/dumps方法实现序列化</h3><p>dumps方法可以将对象转化为字符串，并不具备写入文件的功能</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> json</span><br><span class=\"line\"></span><br><span class=\"line\">file = open(<span class=\"string\">&#x27;text.txt&#x27;</span>, <span class=\"string\">&#x27;w&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">names = [<span class=\"string\">&#x27;zhangsan&#x27;</span>, <span class=\"string\">&#x27;lisi&#x27;</span>, <span class=\"string\">&#x27;wangwu&#x27;</span>, <span class=\"string\">&#x27;merry&#x27;</span>, <span class=\"string\">&#x27;jack&#x27;</span>]</span><br><span class=\"line\"><span class=\"comment\"># file.write(names)    出错，不能直接将列表写入文件中</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 调用json的dumps方法，传入对象，返回json字符串</span></span><br><span class=\"line\">json_result = json.dumps(names)</span><br><span class=\"line\"></span><br><span class=\"line\">print(type(json_result))    <span class=\"comment\"># &lt;class &#x27;str&#x27;&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">file.write(json_result)</span><br><span class=\"line\"></span><br><span class=\"line\">file.close()</span><br></pre></td></tr></table></figure>\n\n<p>dump方法可以在将对象转换成为字符串的同时，指定一个文件对象，把转换后的字符串写入到这个文件里。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> json</span><br><span class=\"line\"></span><br><span class=\"line\">file = open(<span class=\"string\">&#x27;names.txt&#x27;</span>, <span class=\"string\">&#x27;w&#x27;</span>)</span><br><span class=\"line\">names = [<span class=\"string\">&#x27;zhangsan&#x27;</span>, <span class=\"string\">&#x27;lisi&#x27;</span>, <span class=\"string\">&#x27;wangwu&#x27;</span>, <span class=\"string\">&#x27;jerry&#x27;</span>, <span class=\"string\">&#x27;henry&#x27;</span>, <span class=\"string\">&#x27;merry&#x27;</span>, <span class=\"string\">&#x27;chris&#x27;</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># dump方法可以接收一个文件参数，在将对象转换成为字符串的同时写入到文件里</span></span><br><span class=\"line\">json.dump(names, file)</span><br><span class=\"line\">file.close()</span><br></pre></td></tr></table></figure>\n\n<p>注意：如果是一个空对象，调用dumps方法转换成为一个JSON对象，得到的结果是null(JS里的空对象)</p>\n<h3 id=\"load-loads方法实现反序列化\"><a href=\"#load-loads方法实现反序列化\" class=\"headerlink\" title=\"load/loads方法实现反序列化\"></a>load/loads方法实现反序列化</h3><p>loads方法需要一个字符串参数，用来将一个字符串加载成为Python对象。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> json</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 调用loads方法，传入一个字符串，可以将这个字符串加载成为Python对象</span></span><br><span class=\"line\">result = json.loads(<span class=\"string\">&#x27;[&quot;zhangsan&quot;, &quot;lisi&quot;, &quot;wangwu&quot;, &quot;jerry&quot;, &quot;henry&quot;, &quot;merry&quot;, &quot;chris&quot;]&#x27;</span>)</span><br><span class=\"line\">print(type(result))  <span class=\"comment\"># &lt;class &#x27;list&#x27;&gt;</span></span><br><span class=\"line\">Copy</span><br></pre></td></tr></table></figure>\n\n<p>load方法可以传入一个文件对象，用来将一个文件对象里的数据加载成为Python对象。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> json</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 以可读方式打开一个文件</span></span><br><span class=\"line\">file = open(<span class=\"string\">&#x27;names.txt&#x27;</span>, <span class=\"string\">&#x27;r&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 调用load方法，将文件里的内容加载成为一个Python对象</span></span><br><span class=\"line\">result = json.load(file)</span><br><span class=\"line\"></span><br><span class=\"line\">print(result)</span><br><span class=\"line\">file.close()</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"pickle模块序列化\"><a href=\"#pickle模块序列化\" class=\"headerlink\" title=\"pickle模块序列化\"></a>pickle模块序列化</h2><p>和json模块类似，pickle模块也有dump和dumps方法可以对数据进行序列化，同时也有load和loads方法进行反序列化。区别在于，json模块是将对象转换成为字符串，而pickle模块是将对象转换成为二进制。</p>\n<p>pickle模块里方法的使用和json里方法的使用大致相同，需要注意的是，<strong>pickle是将对象转换成为二进制，所以，如果想要把内容写入到文件里，这个文件必须要以二进制的形式打开。</strong></p>\n<h2 id=\"json和pickle的区别\"><a href=\"#json和pickle的区别\" class=\"headerlink\" title=\"json和pickle的区别\"></a>json和pickle的区别</h2><ul>\n<li><p>json模块:</p>\n<ul>\n<li>将对象转化为字符串，而字符串在任何系统和编程语言中都是可以识别的；</li>\n<li>json的用处就是跨平台信息传输；</li>\n<li>python对象与json字符串对应关系：</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>Python</th>\n<th>JSON</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>dict</td>\n<td>object</td>\n</tr>\n<tr>\n<td>list,tuple</td>\n<td>array</td>\n</tr>\n<tr>\n<td>str</td>\n<td>string</td>\n</tr>\n<tr>\n<td>int,float</td>\n<td>number</td>\n</tr>\n<tr>\n<td>True</td>\n<td>true</td>\n</tr>\n<tr>\n<td>False</td>\n<td>false</td>\n</tr>\n<tr>\n<td>None</td>\n<td>null</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>如果是一个自定义对象，默认无法装换成为json字符串，需要手动指定JSONEncoder.</p>\n</li>\n<li><p>如果是将一个json串重新转换成为对象，这个对象里的方法就无法使用了。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> json</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyEncode</span>(<span class=\"params\">json.JSONEncoder</span>):</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">default</span>(<span class=\"params\">self, o</span>):</span></span><br><span class=\"line\">        <span class=\"comment\"># return &#123;&quot;name&quot;:o.name,&quot;age&quot;:o.age&#125;</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> o.__dict__</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span>(<span class=\"params\">object</span>):</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self, name, age</span>):</span></span><br><span class=\"line\">        self.name = name</span><br><span class=\"line\">        self.age = age</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">eat</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">          print(self.name+<span class=\"string\">&#x27;正在吃东西&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">p1 = Person(<span class=\"string\">&#x27;zhangsan&#x27;</span>, <span class=\"number\">18</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 自定义对象想要转换成为json字符串，需要给这个自定义对象指定JSONEncoder</span></span><br><span class=\"line\">result = json.dumps(p1, cls=MyEncode)</span><br><span class=\"line\">print(result)  <span class=\"comment\"># &#123;&quot;name&quot;: &quot;zhangsan&quot;, &quot;age&quot;: 18&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 调用loads方法将对象加载成为一个对象以后，得到的结果是一个字典</span></span><br><span class=\"line\">p = json.loads(result)</span><br><span class=\"line\">print(type(p))</span><br><span class=\"line\">Copy</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>pickle模块：</p>\n<ul>\n<li>pickle序列化是将对象按照一定的规则转换成为二进制保存，它不能跨平台传递数据。</li>\n<li>pickle的序列化会将对象的所有数据都保存。</li>\n<li>pickle适合对需要使用的自定义对象进行序列化处理</li>\n<li>深拷贝也可以使用pickle实现</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"使用with关键字\"><a href=\"#使用with关键字\" class=\"headerlink\" title=\"使用with关键字\"></a>使用with关键字</h1><p>with语句实质上是一个上下文管理器，with语句后的对象都会有<code>__enter__()</code>和<code>__exit__()</code>方法。在进入到上下文时，会自动调用<code>__enter__()</code>方法，程序正常执行完成，或者出现异常中断的时候，都会调用<code>__exit__()</code>方法。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">m3</span>():</span></span><br><span class=\"line\">    <span class=\"keyword\">with</span> open(<span class=\"string\">&quot;output.txt&quot;</span>, <span class=\"string\">&quot;r&quot;</span>) <span class=\"keyword\">as</span> f:</span><br><span class=\"line\">        f.write(<span class=\"string\">&quot;Python之禅&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>open 方法的返回值赋值给变量 f，当离开 with 代码块的时候，系统会自动调用 f.close() 方法。</p>\n<h2 id=\"上下文管理器\"><a href=\"#上下文管理器\" class=\"headerlink\" title=\"上下文管理器\"></a>上下文管理器</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyContext</span>(<span class=\"params\">object</span>):</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self, name, age</span>):</span></span><br><span class=\"line\">        self.name = name</span><br><span class=\"line\">        self.age = age</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__enter__</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        print(<span class=\"string\">&#x27;调用了enter方法&#x27;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> self</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">test</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        <span class=\"number\">1</span> / <span class=\"number\">0</span></span><br><span class=\"line\">        print(self.name + <span class=\"string\">&#x27;调用了test方法&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__exit__</span>(<span class=\"params\">self, exc_type, exc_val, exc_tb</span>):</span></span><br><span class=\"line\">        print(<span class=\"string\">&#x27;调用了exit方法&#x27;</span>)</span><br><span class=\"line\">        print(exc_type, exc_val, exc_tb)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">with</span> MyContext(<span class=\"string\">&#x27;zhangsan&#x27;</span>, <span class=\"number\">18</span>) <span class=\"keyword\">as</span> context:</span><br><span class=\"line\">    context.test()</span><br></pre></td></tr></table></figure>"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"ckknh5t9f00003ntybdxl3ya8","tag_id":"ckknh5t9r00023nty5d5s2cuw","_id":"ckknh5t9v00043nty4srya87p"}],"Tag":[{"name":"MySQL","_id":"ckknh5t9r00023nty5d5s2cuw"}]}}