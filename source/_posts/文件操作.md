---
title: 文件操作
date: 2020-08-01 15:45:03
---

# 文件操作

关于在Python中对文件相关操作的记录

<!--more-->

# 文件的打开

在python中可以使用open函数打开一个已经存在的文件，或者创建一个新文件。

```python
file = open('../a.txt', 'w')
```

## 访问模式

```python
open(file, mode='r', buffering=None, encoding=None, errors=None, newline=None, closefd=True)
```

|   访问模式   | 说明                                                         |
| :----------: | :----------------------------------------------------------- |
|      r       | 只读——已存在则从头开始——不存在则报错——读完不重新open文件指针不会复原<br />这是默认模式。** |
|      w       | 只写——已存在则覆写——不存在则创建新文件——同一次文件指针不会复原（等同于追加）——重新open就会覆写 |
|      a       | 追加——已存在则追加原内容之后——不存在则创建新文件——只写不读   |
|      r+      | 读写——文件指针默认在文件开始位置，写入会覆盖相同长度的原内容——操作之后文件指针不会复原 |
|      w+      | 读写——文件已存在则将其覆盖——文件不存在则创建新文件——每次open都是清空原内容，但是写入操作之后文件指针在文件末，此时读会为空，需要重置指针 |
|      a+      | 追加方式读写——文件已存在，文件指针将会放在文件的结尾，可以直接追加，所以读为空——文件不存在，创建新文件用于读写 |
|      b       | 二进制格式操作                                               |
|      t       | 文本模式                                                     |
|      U       | 通用换行符，将所有的\n、\r 都替换成 \n<br />（universal newline mode (deprecated)） |
|  buffering   | 为了减少I/O操作，使用缓冲区，达到要求的数据量才进行系统调用<br />全缓冲：buffering=1024        设置大于1的整数表示缓冲区大小<br />行缓冲：buffering=1        按行缓冲，适用于文本内容<br />无缓冲：buffering=0        来一个处理一个，只适用于二进制模式 |
|   encoding   | 返回数据采用何种编码方式进行解码——‘utf-8’、‘gbk’             |
|    errors    | 取值一般有strict，ignore，当取strict的时候，字符编码出现问题的时候，会报错，当取ignore的时候，编码出现问题，程序会忽略而过，继续执行下面的程序 |
|   newline    | 可以取的值有None, \n, \r, ”, ‘\r\n’，用于区分换行符，但是这个参数只对文本模式有效 |
| 文件指针操作 | file.tell    查看指针当前位置<br />file.seek(0)    将指针移到文件开头 |

# 文件关闭

文件打开之后一定要关闭

```python
file.close()
```

# 文件的读写

## 写数据

使用 write() 向文件写数据

```python
file.open('test.txt', 'w')
file.write('hello world, i am here!\n' * 5)
file.close()
```

## 读数据

使用read(num)可以从文件中读取数据，num表示读取的数据长度，单位是字节。

```python
one_k = file.read(1024)
print(one_k)
# 同一次open内不会还原文件指针位置
# 会读取接下来的所有内容
last = file.read()
print(last)
```

使用readlines() 可以按照行的方式将整个文件的内容进行一次性读取，返回一个列表，每一行为列表的一个元素。

```python
content = f.readlines()
print(type(content))

for temp in content:
    print(temp)
```

## 重置指针位置

seek(offset, whence) 方法重置文件指针的位置

- offset：表示偏移量
- whence：表示指针移动位置，只能传入0、1、2
  - 0表示从文件头开始
  - 1表示从当前位置开始，配合偏移量使用
  - 2表示从文件末尾开始

```python
f.seek(2,0)   # 从文件的开头开始，跳过两个字节
print(f.read())

f.seek(1,1) # 从当前位置开始，跳过一个字节
print(f.read())

f.seek(-4,2) # 从文件末尾开始，往前跳过四个字节
print(f.read())
```

# CSV文件

```python
import csv

# 先以写入模式打开一个csv文件
csvfile = open('tst.csv', 'w')

# csv的writer方法将文件对象变成CSVWriter对象
csvwriter = csv.writer(file)

# 调用CSVWriter的writerow方法可以按行写入数据
csvwrite.writerow(['name', 'age', 'score'])

# writerows方法可以一次性写入多行
csvwriter.writerows(['zhangsan', '18', '98'], ['lisi', '19', '99'], ['wangwu', '18', '97'])

# 调用csv模块的reader方法，得到的结果是一个可迭代对象
reader = csv.reader(file)

# 对结果进行遍历，获取到结果里的每一行数据
for row in reader:
    print(row)

file.close()
```

# 数据写入内存

## StringIO

StringIO可以将字符串写入到内存中，像操作文件一下操作字符串。

```python
from io import StringIO

# 创建一个StringIO对象
f = StringIO()
# 可以像操作文件一下，将字符串写入到内存中
f.write('hello\r\n')
f.write('good')

# 使用文件的 readline和readlines方法，无法读取到数据
# print(f.readline())
# print(f.readlines())

# 需要调用getvalue()方法才能获取到写入到内存中的数据
print(f.getvalue())

f.close()
```

## BytesIO

如果想要以二进制的形式写入数据，可以使用BytesIO类，它的用法和StringIO相似，只不过在调用write方法写入时，**需要传入二进制数据**。

```python
from io import BytesIO

f = BytesIO()
f.write('你好\r\n'.encode('utf-8'))
f.write('中国'.encode('utf-8'))

print(f.getvalue())
f.close()
```

# 序列化和反序列化

将对象序列化之后才能写入文件，也可以将文件中的字节（字符）反序列化为python对象（列表、字典、元组。。。）

## JSON模块序列化

JSON(JavaScriptObjectNotation, JS对象简谱)是一种轻量级的数据交换格式，它基于 ECMAScript 的一个子集，采用完全独立于编程语言的**文本格式**来存储和表示数据。**JSON的本质是字符串**！

### dump/dumps方法实现序列化

dumps方法可以将对象转化为字符串，并不具备写入文件的功能

```python
import json

file = open('text.txt', 'w')

names = ['zhangsan', 'lisi', 'wangwu', 'merry', 'jack']
# file.write(names)    出错，不能直接将列表写入文件中

# 调用json的dumps方法，传入对象，返回json字符串
json_result = json.dumps(names)

print(type(json_result))    # <class 'str'>

file.write(json_result)

file.close()
```

dump方法可以在将对象转换成为字符串的同时，指定一个文件对象，把转换后的字符串写入到这个文件里。

```python
import json

file = open('names.txt', 'w')
names = ['zhangsan', 'lisi', 'wangwu', 'jerry', 'henry', 'merry', 'chris']

# dump方法可以接收一个文件参数，在将对象转换成为字符串的同时写入到文件里
json.dump(names, file)
file.close()
```

注意：如果是一个空对象，调用dumps方法转换成为一个JSON对象，得到的结果是null(JS里的空对象)

### load/loads方法实现反序列化

loads方法需要一个字符串参数，用来将一个字符串加载成为Python对象。

```python
import json

# 调用loads方法，传入一个字符串，可以将这个字符串加载成为Python对象
result = json.loads('["zhangsan", "lisi", "wangwu", "jerry", "henry", "merry", "chris"]')
print(type(result))  # <class 'list'>
Copy
```

load方法可以传入一个文件对象，用来将一个文件对象里的数据加载成为Python对象。

```python
import json

# 以可读方式打开一个文件
file = open('names.txt', 'r')

# 调用load方法，将文件里的内容加载成为一个Python对象
result = json.load(file)

print(result)
file.close()
```

## pickle模块序列化

和json模块类似，pickle模块也有dump和dumps方法可以对数据进行序列化，同时也有load和loads方法进行反序列化。区别在于，json模块是将对象转换成为字符串，而pickle模块是将对象转换成为二进制。

pickle模块里方法的使用和json里方法的使用大致相同，需要注意的是，**pickle是将对象转换成为二进制，所以，如果想要把内容写入到文件里，这个文件必须要以二进制的形式打开。**

## json和pickle的区别

- json模块:

  - 将对象转化为字符串，而字符串在任何系统和编程语言中都是可以识别的；
  - json的用处就是跨平台信息传输；
  - python对象与json字符串对应关系：

  | Python     | JSON   |
  | ---------- | ------ |
  | dict       | object |
  | list,tuple | array  |
  | str        | string |
  | int,float  | number |
  | True       | true   |
  | False      | false  |
  | None       | null   |

- 如果是一个自定义对象，默认无法装换成为json字符串，需要手动指定JSONEncoder.

- 如果是将一个json串重新转换成为对象，这个对象里的方法就无法使用了。

  ```python
  import json
  class MyEncode(json.JSONEncoder):
      def default(self, o):
          # return {"name":o.name,"age":o.age}
          return o.__dict__
  
  class Person(object):
      def __init__(self, name, age):
          self.name = name
          self.age = age
  
        def eat(self):
            print(self.name+'正在吃东西')
  
  p1 = Person('zhangsan', 18)
  
  # 自定义对象想要转换成为json字符串，需要给这个自定义对象指定JSONEncoder
  result = json.dumps(p1, cls=MyEncode)
  print(result)  # {"name": "zhangsan", "age": 18}
  
  # 调用loads方法将对象加载成为一个对象以后，得到的结果是一个字典
  p = json.loads(result)
  print(type(p))
  Copy
  ```

- pickle模块：
  - pickle序列化是将对象按照一定的规则转换成为二进制保存，它不能跨平台传递数据。
  - pickle的序列化会将对象的所有数据都保存。
  - pickle适合对需要使用的自定义对象进行序列化处理
  - 深拷贝也可以使用pickle实现

# 使用with关键字

with语句实质上是一个上下文管理器，with语句后的对象都会有`__enter__()`和`__exit__()`方法。在进入到上下文时，会自动调用`__enter__()`方法，程序正常执行完成，或者出现异常中断的时候，都会调用`__exit__()`方法。

```python
def m3():
    with open("output.txt", "r") as f:
        f.write("Python之禅")
```

open 方法的返回值赋值给变量 f，当离开 with 代码块的时候，系统会自动调用 f.close() 方法。

## 上下文管理器

```python
class MyContext(object):
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def __enter__(self):
        print('调用了enter方法')
        return self

    def test(self):
        1 / 0
        print(self.name + '调用了test方法')

    def __exit__(self, exc_type, exc_val, exc_tb):
        print('调用了exit方法')
        print(exc_type, exc_val, exc_tb)

with MyContext('zhangsan', 18) as context:
    context.test()
```
