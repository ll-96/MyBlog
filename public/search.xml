<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2021/02/02/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<a id="more"></a>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>文件操作</title>
    <url>/2020/08/01/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h1><p>关于在Python中对文件相关操作的记录</p>
<a id="more"></a>

<h1 id="文件的打开"><a href="#文件的打开" class="headerlink" title="文件的打开"></a>文件的打开</h1><p>在python中可以使用open函数打开一个已经存在的文件，或者创建一个新文件。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">file = open(<span class="string">&#x27;../a.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="访问模式"><a href="#访问模式" class="headerlink" title="访问模式"></a>访问模式</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">open(file, mode=<span class="string">&#x27;r&#x27;</span>, buffering=<span class="literal">None</span>, encoding=<span class="literal">None</span>, errors=<span class="literal">None</span>, newline=<span class="literal">None</span>, closefd=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">访问模式</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">r</td>
<td align="left">只读——已存在则从头开始——不存在则报错——读完不重新open文件指针不会复原<br />这是默认模式。**</td>
</tr>
<tr>
<td align="center">w</td>
<td align="left">只写——已存在则覆写——不存在则创建新文件——同一次文件指针不会复原（等同于追加）——重新open就会覆写</td>
</tr>
<tr>
<td align="center">a</td>
<td align="left">追加——已存在则追加原内容之后——不存在则创建新文件——只写不读</td>
</tr>
<tr>
<td align="center">r+</td>
<td align="left">读写——文件指针默认在文件开始位置，写入会覆盖相同长度的原内容——操作之后文件指针不会复原</td>
</tr>
<tr>
<td align="center">w+</td>
<td align="left">读写——文件已存在则将其覆盖——文件不存在则创建新文件——每次open都是清空原内容，但是写入操作之后文件指针在文件末，此时读会为空，需要重置指针</td>
</tr>
<tr>
<td align="center">a+</td>
<td align="left">追加方式读写——文件已存在，文件指针将会放在文件的结尾，可以直接追加，所以读为空——文件不存在，创建新文件用于读写</td>
</tr>
<tr>
<td align="center">b</td>
<td align="left">二进制格式操作</td>
</tr>
<tr>
<td align="center">t</td>
<td align="left">文本模式</td>
</tr>
<tr>
<td align="center">U</td>
<td align="left">通用换行符，将所有的\n、\r 都替换成 \n<br />（universal newline mode (deprecated)）</td>
</tr>
<tr>
<td align="center">buffering</td>
<td align="left">为了减少I/O操作，使用缓冲区，达到要求的数据量才进行系统调用<br />全缓冲：buffering=1024        设置大于1的整数表示缓冲区大小<br />行缓冲：buffering=1        按行缓冲，适用于文本内容<br />无缓冲：buffering=0        来一个处理一个，只适用于二进制模式</td>
</tr>
<tr>
<td align="center">encoding</td>
<td align="left">返回数据采用何种编码方式进行解码——‘utf-8’、‘gbk’</td>
</tr>
<tr>
<td align="center">errors</td>
<td align="left">取值一般有strict，ignore，当取strict的时候，字符编码出现问题的时候，会报错，当取ignore的时候，编码出现问题，程序会忽略而过，继续执行下面的程序</td>
</tr>
<tr>
<td align="center">newline</td>
<td align="left">可以取的值有None, \n, \r, ”, ‘\r\n’，用于区分换行符，但是这个参数只对文本模式有效</td>
</tr>
<tr>
<td align="center">文件指针操作</td>
<td align="left">file.tell    查看指针当前位置<br />file.seek(0)    将指针移到文件开头</td>
</tr>
</tbody></table>
<h1 id="文件关闭"><a href="#文件关闭" class="headerlink" title="文件关闭"></a>文件关闭</h1><p>文件打开之后一定要关闭</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">file.close()</span><br></pre></td></tr></table></figure>

<h1 id="文件的读写"><a href="#文件的读写" class="headerlink" title="文件的读写"></a>文件的读写</h1><h2 id="写数据"><a href="#写数据" class="headerlink" title="写数据"></a>写数据</h2><p>使用 write() 向文件写数据</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">file.open(<span class="string">&#x27;test.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">file.write(<span class="string">&#x27;hello world, i am here!\n&#x27;</span> * <span class="number">5</span>)</span><br><span class="line">file.close()</span><br></pre></td></tr></table></figure>

<h2 id="读数据"><a href="#读数据" class="headerlink" title="读数据"></a>读数据</h2><p>使用read(num)可以从文件中读取数据，num表示读取的数据长度，单位是字节。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">one_k = file.read(<span class="number">1024</span>)</span><br><span class="line">print(one_k)</span><br><span class="line"><span class="comment"># 同一次open内不会还原文件指针位置</span></span><br><span class="line"><span class="comment"># 会读取接下来的所有内容</span></span><br><span class="line">last = file.read()</span><br><span class="line">print(last)</span><br></pre></td></tr></table></figure>

<p>使用readlines() 可以按照行的方式将整个文件的内容进行一次性读取，返回一个列表，每一行为列表的一个元素。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">content = f.readlines()</span><br><span class="line">print(type(content))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> temp <span class="keyword">in</span> content:</span><br><span class="line">    print(temp)</span><br></pre></td></tr></table></figure>

<h2 id="重置指针位置"><a href="#重置指针位置" class="headerlink" title="重置指针位置"></a>重置指针位置</h2><p>seek(offset, whence) 方法重置文件指针的位置</p>
<ul>
<li>offset：表示偏移量</li>
<li>whence：表示指针移动位置，只能传入0、1、2<ul>
<li>0表示从文件头开始</li>
<li>1表示从当前位置开始，配合偏移量使用</li>
<li>2表示从文件末尾开始</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f.seek(<span class="number">2</span>,<span class="number">0</span>)   <span class="comment"># 从文件的开头开始，跳过两个字节</span></span><br><span class="line">print(f.read())</span><br><span class="line"></span><br><span class="line">f.seek(<span class="number">1</span>,<span class="number">1</span>) <span class="comment"># 从当前位置开始，跳过一个字节</span></span><br><span class="line">print(f.read())</span><br><span class="line"></span><br><span class="line">f.seek(<span class="number">-4</span>,<span class="number">2</span>) <span class="comment"># 从文件末尾开始，往前跳过四个字节</span></span><br><span class="line">print(f.read())</span><br></pre></td></tr></table></figure>

<h1 id="CSV文件"><a href="#CSV文件" class="headerlink" title="CSV文件"></a>CSV文件</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"></span><br><span class="line"><span class="comment"># 先以写入模式打开一个csv文件</span></span><br><span class="line">csvfile = open(<span class="string">&#x27;tst.csv&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># csv的writer方法将文件对象变成CSVWriter对象</span></span><br><span class="line">csvwriter = csv.writer(file)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用CSVWriter的writerow方法可以按行写入数据</span></span><br><span class="line">csvwrite.writerow([<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;score&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># writerows方法可以一次性写入多行</span></span><br><span class="line">csvwriter.writerows([<span class="string">&#x27;zhangsan&#x27;</span>, <span class="string">&#x27;18&#x27;</span>, <span class="string">&#x27;98&#x27;</span>], [<span class="string">&#x27;lisi&#x27;</span>, <span class="string">&#x27;19&#x27;</span>, <span class="string">&#x27;99&#x27;</span>], [<span class="string">&#x27;wangwu&#x27;</span>, <span class="string">&#x27;18&#x27;</span>, <span class="string">&#x27;97&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用csv模块的reader方法，得到的结果是一个可迭代对象</span></span><br><span class="line">reader = csv.reader(file)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对结果进行遍历，获取到结果里的每一行数据</span></span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> reader:</span><br><span class="line">    print(row)</span><br><span class="line"></span><br><span class="line">file.close()</span><br></pre></td></tr></table></figure>

<h1 id="数据写入内存"><a href="#数据写入内存" class="headerlink" title="数据写入内存"></a>数据写入内存</h1><h2 id="StringIO"><a href="#StringIO" class="headerlink" title="StringIO"></a>StringIO</h2><p>StringIO可以将字符串写入到内存中，像操作文件一下操作字符串。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> io <span class="keyword">import</span> StringIO</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个StringIO对象</span></span><br><span class="line">f = StringIO()</span><br><span class="line"><span class="comment"># 可以像操作文件一下，将字符串写入到内存中</span></span><br><span class="line">f.write(<span class="string">&#x27;hello\r\n&#x27;</span>)</span><br><span class="line">f.write(<span class="string">&#x27;good&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用文件的 readline和readlines方法，无法读取到数据</span></span><br><span class="line"><span class="comment"># print(f.readline())</span></span><br><span class="line"><span class="comment"># print(f.readlines())</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 需要调用getvalue()方法才能获取到写入到内存中的数据</span></span><br><span class="line">print(f.getvalue())</span><br><span class="line"></span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>

<h2 id="BytesIO"><a href="#BytesIO" class="headerlink" title="BytesIO"></a>BytesIO</h2><p>如果想要以二进制的形式写入数据，可以使用BytesIO类，它的用法和StringIO相似，只不过在调用write方法写入时，<strong>需要传入二进制数据</strong>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> io <span class="keyword">import</span> BytesIO</span><br><span class="line"></span><br><span class="line">f = BytesIO()</span><br><span class="line">f.write(<span class="string">&#x27;你好\r\n&#x27;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">f.write(<span class="string">&#x27;中国&#x27;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line">print(f.getvalue())</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>

<h1 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a>序列化和反序列化</h1><p>将对象序列化之后才能写入文件，也可以将文件中的字节（字符）反序列化为python对象（列表、字典、元组。。。）</p>
<h2 id="JSON模块序列化"><a href="#JSON模块序列化" class="headerlink" title="JSON模块序列化"></a>JSON模块序列化</h2><p>JSON(JavaScriptObjectNotation, JS对象简谱)是一种轻量级的数据交换格式，它基于 ECMAScript 的一个子集，采用完全独立于编程语言的<strong>文本格式</strong>来存储和表示数据。<strong>JSON的本质是字符串</strong>！</p>
<h3 id="dump-dumps方法实现序列化"><a href="#dump-dumps方法实现序列化" class="headerlink" title="dump/dumps方法实现序列化"></a>dump/dumps方法实现序列化</h3><p>dumps方法可以将对象转化为字符串，并不具备写入文件的功能</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">file = open(<span class="string">&#x27;text.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"></span><br><span class="line">names = [<span class="string">&#x27;zhangsan&#x27;</span>, <span class="string">&#x27;lisi&#x27;</span>, <span class="string">&#x27;wangwu&#x27;</span>, <span class="string">&#x27;merry&#x27;</span>, <span class="string">&#x27;jack&#x27;</span>]</span><br><span class="line"><span class="comment"># file.write(names)    出错，不能直接将列表写入文件中</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用json的dumps方法，传入对象，返回json字符串</span></span><br><span class="line">json_result = json.dumps(names)</span><br><span class="line"></span><br><span class="line">print(type(json_result))    <span class="comment"># &lt;class &#x27;str&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line">file.write(json_result)</span><br><span class="line"></span><br><span class="line">file.close()</span><br></pre></td></tr></table></figure>

<p>dump方法可以在将对象转换成为字符串的同时，指定一个文件对象，把转换后的字符串写入到这个文件里。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">file = open(<span class="string">&#x27;names.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">names = [<span class="string">&#x27;zhangsan&#x27;</span>, <span class="string">&#x27;lisi&#x27;</span>, <span class="string">&#x27;wangwu&#x27;</span>, <span class="string">&#x27;jerry&#x27;</span>, <span class="string">&#x27;henry&#x27;</span>, <span class="string">&#x27;merry&#x27;</span>, <span class="string">&#x27;chris&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># dump方法可以接收一个文件参数，在将对象转换成为字符串的同时写入到文件里</span></span><br><span class="line">json.dump(names, file)</span><br><span class="line">file.close()</span><br></pre></td></tr></table></figure>

<p>注意：如果是一个空对象，调用dumps方法转换成为一个JSON对象，得到的结果是null(JS里的空对象)</p>
<h3 id="load-loads方法实现反序列化"><a href="#load-loads方法实现反序列化" class="headerlink" title="load/loads方法实现反序列化"></a>load/loads方法实现反序列化</h3><p>loads方法需要一个字符串参数，用来将一个字符串加载成为Python对象。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用loads方法，传入一个字符串，可以将这个字符串加载成为Python对象</span></span><br><span class="line">result = json.loads(<span class="string">&#x27;[&quot;zhangsan&quot;, &quot;lisi&quot;, &quot;wangwu&quot;, &quot;jerry&quot;, &quot;henry&quot;, &quot;merry&quot;, &quot;chris&quot;]&#x27;</span>)</span><br><span class="line">print(type(result))  <span class="comment"># &lt;class &#x27;list&#x27;&gt;</span></span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>load方法可以传入一个文件对象，用来将一个文件对象里的数据加载成为Python对象。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以可读方式打开一个文件</span></span><br><span class="line">file = open(<span class="string">&#x27;names.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用load方法，将文件里的内容加载成为一个Python对象</span></span><br><span class="line">result = json.load(file)</span><br><span class="line"></span><br><span class="line">print(result)</span><br><span class="line">file.close()</span><br></pre></td></tr></table></figure>

<h2 id="pickle模块序列化"><a href="#pickle模块序列化" class="headerlink" title="pickle模块序列化"></a>pickle模块序列化</h2><p>和json模块类似，pickle模块也有dump和dumps方法可以对数据进行序列化，同时也有load和loads方法进行反序列化。区别在于，json模块是将对象转换成为字符串，而pickle模块是将对象转换成为二进制。</p>
<p>pickle模块里方法的使用和json里方法的使用大致相同，需要注意的是，<strong>pickle是将对象转换成为二进制，所以，如果想要把内容写入到文件里，这个文件必须要以二进制的形式打开。</strong></p>
<h2 id="json和pickle的区别"><a href="#json和pickle的区别" class="headerlink" title="json和pickle的区别"></a>json和pickle的区别</h2><ul>
<li><p>json模块:</p>
<ul>
<li>将对象转化为字符串，而字符串在任何系统和编程语言中都是可以识别的；</li>
<li>json的用处就是跨平台信息传输；</li>
<li>python对象与json字符串对应关系：</li>
</ul>
<table>
<thead>
<tr>
<th>Python</th>
<th>JSON</th>
</tr>
</thead>
<tbody><tr>
<td>dict</td>
<td>object</td>
</tr>
<tr>
<td>list,tuple</td>
<td>array</td>
</tr>
<tr>
<td>str</td>
<td>string</td>
</tr>
<tr>
<td>int,float</td>
<td>number</td>
</tr>
<tr>
<td>True</td>
<td>true</td>
</tr>
<tr>
<td>False</td>
<td>false</td>
</tr>
<tr>
<td>None</td>
<td>null</td>
</tr>
</tbody></table>
</li>
<li><p>如果是一个自定义对象，默认无法装换成为json字符串，需要手动指定JSONEncoder.</p>
</li>
<li><p>如果是将一个json串重新转换成为对象，这个对象里的方法就无法使用了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyEncode</span>(<span class="params">json.JSONEncoder</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">default</span>(<span class="params">self, o</span>):</span></span><br><span class="line">        <span class="comment"># return &#123;&quot;name&quot;:o.name,&quot;age&quot;:o.age&#125;</span></span><br><span class="line">        <span class="keyword">return</span> o.__dict__</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">eat</span>(<span class="params">self</span>):</span></span><br><span class="line">          print(self.name+<span class="string">&#x27;正在吃东西&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p1 = Person(<span class="string">&#x27;zhangsan&#x27;</span>, <span class="number">18</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义对象想要转换成为json字符串，需要给这个自定义对象指定JSONEncoder</span></span><br><span class="line">result = json.dumps(p1, cls=MyEncode)</span><br><span class="line">print(result)  <span class="comment"># &#123;&quot;name&quot;: &quot;zhangsan&quot;, &quot;age&quot;: 18&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用loads方法将对象加载成为一个对象以后，得到的结果是一个字典</span></span><br><span class="line">p = json.loads(result)</span><br><span class="line">print(type(p))</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>
</li>
<li><p>pickle模块：</p>
<ul>
<li>pickle序列化是将对象按照一定的规则转换成为二进制保存，它不能跨平台传递数据。</li>
<li>pickle的序列化会将对象的所有数据都保存。</li>
<li>pickle适合对需要使用的自定义对象进行序列化处理</li>
<li>深拷贝也可以使用pickle实现</li>
</ul>
</li>
</ul>
<h1 id="使用with关键字"><a href="#使用with关键字" class="headerlink" title="使用with关键字"></a>使用with关键字</h1><p>with语句实质上是一个上下文管理器，with语句后的对象都会有<code>__enter__()</code>和<code>__exit__()</code>方法。在进入到上下文时，会自动调用<code>__enter__()</code>方法，程序正常执行完成，或者出现异常中断的时候，都会调用<code>__exit__()</code>方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">m3</span>():</span></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">&quot;output.txt&quot;</span>, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(<span class="string">&quot;Python之禅&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>open 方法的返回值赋值给变量 f，当离开 with 代码块的时候，系统会自动调用 f.close() 方法。</p>
<h2 id="上下文管理器"><a href="#上下文管理器" class="headerlink" title="上下文管理器"></a>上下文管理器</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyContext</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;调用了enter方法&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="number">1</span> / <span class="number">0</span></span><br><span class="line">        print(self.name + <span class="string">&#x27;调用了test方法&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span>(<span class="params">self, exc_type, exc_val, exc_tb</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;调用了exit方法&#x27;</span>)</span><br><span class="line">        print(exc_type, exc_val, exc_tb)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> MyContext(<span class="string">&#x27;zhangsan&#x27;</span>, <span class="number">18</span>) <span class="keyword">as</span> context:</span><br><span class="line">    context.test()</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>MySQL相关总结</title>
    <url>/2020/07/14/MySQL%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="MySQL-数据库"><a href="#MySQL-数据库" class="headerlink" title="MySQL 数据库"></a>MySQL 数据库</h1><p>MySQL 是最流行的关系型数据库管理系统，在 WEB 应用方面 MySQL 是最好的 RDBMS(Relational Database Management System：关系数据库管理系统)应用软件之一。</p>
<a id="more"></a>

<h1 id="MySQL存储引擎"><a href="#MySQL存储引擎" class="headerlink" title="MySQL存储引擎"></a>MySQL存储引擎</h1><h2 id="查看当前存储引擎"><a href="#查看当前存储引擎" class="headerlink" title="查看当前存储引擎"></a>查看当前存储引擎</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">&#x27;%storage_engine&#x27;</span>;</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">engines</span>;</span><br></pre></td></tr></table></figure>

<h2 id="MySQL常用引擎"><a href="#MySQL常用引擎" class="headerlink" title="MySQL常用引擎"></a>MySQL常用引擎</h2><ol>
<li><p>InnoDB</p>
<p>事务型数据库的首选引擎，支持事务安全表（ACID），支持行锁定和外键，InnoDB是默认的MySQL引擎。</p>
<p>InnoDB主要特性有：</p>
<ol>
<li>InnoDB 给 MySQL 提供了具有提交、回滚、崩溃恢复能力的事务安全存储引擎。</li>
<li>InnoDB 是为处理巨大数据量的最大性能设计。它的 CPU 效率比其他基于磁盘的关系型数据库引擎高。</li>
<li>InnoDB 存储引擎自带缓冲池，可以将数据和索引缓存在内存中。</li>
<li>InnoDB 支持外键完整性约束。</li>
<li>InnoDB 被用在众多需要高性能的大型数据库站点上</li>
<li>InnoDB 支持行级锁</li>
</ol>
</li>
<li><p>MyISAM</p>
<p>MyISAM 基于 ISAM 存储引擎，并对其进行扩展。它是在Web、数据仓储和其他应用环境下最常使用的存储引擎之一。MyISAM 拥有较高的插入、查询速度，但不支持事物。</p>
<p>MyISAM主要特性有：</p>
<ol>
<li>大文件支持更好</li>
<li>当删除、更新、插入混用时，产生更少碎片。</li>
<li>每个 MyISAM 表最大索引数是64，这可以通过重新编译来改变。每个索引最大的列数是16</li>
<li>最大的键长度是1000字节。</li>
<li>BLOB和TEXT列可以被索引</li>
<li>NULL 被允许在索引的列中，这个值占每个键的0~1个字节</li>
<li>所有数字键值以高字节优先被存储以允许一个更高的索引压缩</li>
<li>MyISAM 类型表的 AUTO_INCREMENT 列更新比 InnoDB 类型的 AUTO_INCREMENT 更快</li>
<li>可以把数据文件和索引文件放在不同目录</li>
<li>每个字符列可以有不同的字符集</li>
<li>有 VARCHAR 的表可以固定或动态记录长度</li>
<li>VARCHAR 和 CHAR 列可以多达 64KB</li>
<li>只支持表锁</li>
</ol>
</li>
<li><p>MEMORY</p>
<p>MEMORY 存储引擎将表中的数据存储到内存中，为查询和引用其他表数据提供快速访问。</p>
</li>
</ol>
<h2 id="存储引擎的选择"><a href="#存储引擎的选择" class="headerlink" title="存储引擎的选择"></a>存储引擎的选择</h2><p>一般来说，对插入和并发性能要求较高的，或者需要外键，或者需要事务支持的情况下，需要选择 InnoDB，</p>
<p>插入较少，查询较多的场景，优先考虑 MyISAM。</p>
<h3 id="使用引擎"><a href="#使用引擎" class="headerlink" title="使用引擎"></a>使用引擎</h3><p>一般在建表时添加</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table abc (</span><br><span class="line">    name char(10)</span><br><span class="line">) engine&#x3D;MyISAM charset&#x3D;utf8;</span><br><span class="line"></span><br><span class="line">create table xyz (</span><br><span class="line">    name char(10)</span><br><span class="line">) engine&#x3D;InnoDB charset&#x3D;utf8;</span><br></pre></td></tr></table></figure>

<h3 id="InnoDB-和-MyISAM-在文件方面的区别"><a href="#InnoDB-和-MyISAM-在文件方面的区别" class="headerlink" title="InnoDB 和 MyISAM 在文件方面的区别"></a>InnoDB 和 MyISAM 在文件方面的区别</h3><ol>
<li><p>InnoDB 将一张表存储为两个文件</p>
<ul>
<li>demo.frm -&gt; 存储表的结构和索引</li>
<li>demo.ibd -&gt; 存储数据，ibd 存储是有限的, 存储不足自动创建 ibd1, ibd2</li>
<li>InnoDB 的文件创建在对应的数据库中, 不能任意的移动</li>
</ul>
</li>
<li><p>MyISAM 将一张表存储为三个文件</p>
<ul>
<li><p>demo.frm -&gt; 存储表的结构</p>
</li>
<li><p>demo.myd -&gt; 存储数据</p>
</li>
<li><p>demo.myi -&gt; 存储表的索引</p>
</li>
<li><p>MyISAM 的文件可以任意的移动</p>
</li>
</ul>
</li>
</ol>
<h1 id="MySQL索引"><a href="#MySQL索引" class="headerlink" title="MySQL索引"></a>MySQL索引</h1><h2 id="索引介绍"><a href="#索引介绍" class="headerlink" title="索引介绍"></a>索引介绍</h2><h3 id="索引是什么"><a href="#索引是什么" class="headerlink" title="索引是什么"></a>索引是什么</h3><ul>
<li><p>索引是帮助MySQL<strong>高效获取数据的数据结构</strong>，能<strong>加快数据库检索速度</strong>、<strong>排序</strong>等，类似于一本书的目录。</p>
</li>
<li><p>索引本身往往是存储在磁盘上的文件中的（单独的索引文件或者是和数据库一起存储在数据文件中（InnoDB））</p>
</li>
<li><p>包括<strong>聚集索引、覆盖索引、组合索引、前缀索引、唯一索引等</strong>，一般默认使用的都是<strong>B+树结构</strong>的索引</p>
</li>
</ul>
<h3 id="索引的优势和劣势"><a href="#索引的优势和劣势" class="headerlink" title="索引的优势和劣势"></a>索引的优势和劣势</h3><p><strong>优势：</strong></p>
<ul>
<li>可以<strong>提高数据检索的效率</strong>，降低数据库的IO成本；</li>
<li>可以通过索引<strong>对数据进行排序</strong>，降低数据排序的成本，减少CPU消耗；<ul>
<li>被索引的列会自动排序，包括<strong>单列索引</strong>和<strong>组合索引</strong>；</li>
<li>按照索引列的顺序进行order by <strong>排序效率会提高</strong>很多；</li>
<li>where 索引列 在存储引擎层处理；</li>
</ul>
</li>
</ul>
<p><strong>劣势：</strong></p>
<ul>
<li>会<strong>占用内存空间</strong>；</li>
<li>虽然会提高搜索效率，但是会<strong>降低更新表的效率</strong>，因为每次修改不光要修改表数据，还要修改对应的索引文件；</li>
</ul>
<h2 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h2><h3 id="单列索引"><a href="#单列索引" class="headerlink" title="单列索引"></a>单列索引</h3><ul>
<li>普通索引：MySQL中最基本的索引，没有什么限制，允许在定义索引的列中插入重复值的空值，纯粹是为了查询更快；(<strong>add index</strong>)</li>
<li>唯一索引：索引中的值必须是唯一的，但是允许为空值；(<strong>add unique index</strong>)</li>
<li>主键索引：特殊的唯一索引，不允许为空值。pk</li>
</ul>
<h3 id="组合索引"><a href="#组合索引" class="headerlink" title="组合索引"></a>组合索引</h3><ul>
<li>多个字段组合上创建的索引；(<strong>add index(col1, col2,…)</strong>)</li>
<li>需要遵循<strong>最左前缀原则（最左匹配原则）</strong></li>
<li>一般<strong>建议使用组合索引代替单列索引（主键除外）</strong></li>
</ul>
<h3 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h3><p>只有在MyISAM、InnoDB（5.6以后）上才能使用，而且只能在CHAR、VARCHAR、TEXT类型字段上使用全文索引。</p>
<p>优先级最高，最先执行，不会执行其他索引</p>
<h3 id="空间索引"><a href="#空间索引" class="headerlink" title="空间索引"></a>空间索引</h3><h2 id="索引的使用"><a href="#索引的使用" class="headerlink" title="索引的使用"></a>索引的使用</h2><h3 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h3><ul>
<li><p>单列索引——普通索引</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">CREATE INDEX index_name ON table_name (column_name);</span><br><span class="line">ALTER TABLE table_name ADD INDEX index_name (column_name);</span><br></pre></td></tr></table></figure>
</li>
<li><p>单列索引——唯一索引</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">CREATE UNIQUE INDEX index_name ON table_name (column_name);</span><br><span class="line">ALTER TABLE table_name ADD UNIQUE INDEX index_name(column_name);</span><br></pre></td></tr></table></figure>
</li>
<li><p>单列索引——全文索引</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">CREATE UNIQUE FULLTEXT INDEX fulltext_index_name ON table_name (column_name)</span><br></pre></td></tr></table></figure>
</li>
<li><p>组合索引</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">CREATE INDEX index_name ON table_name (column_name_1, column_name_2);</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">DROP INDEX index_name ON table_name;</span><br></pre></td></tr></table></figure>

<h3 id="查看索引"><a href="#查看索引" class="headerlink" title="查看索引"></a>查看索引</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">SHOW INDEX FROM table_name;</span><br></pre></td></tr></table></figure>



<h2 id="索引原理分析"><a href="#索引原理分析" class="headerlink" title="索引原理分析"></a>索引原理分析</h2><h3 id="索引的存储结构"><a href="#索引的存储结构" class="headerlink" title="索引的存储结构"></a>索引的存储结构</h3><ul>
<li>索引是在<strong>存储引擎中实现</strong>的，也就是说使用不同的存储引擎，会使用不同的索引；</li>
<li><strong>MyISAM</strong> 和 <strong>InnoDB</strong> 存储引擎：<strong>只支持 B+TREE 索引</strong>，<strong>默认使用BTREE</strong>，不能更换；</li>
<li>MEMORY/HEAP 存储引擎：支持HASH和BTREE索引；<br>(HASH索引比BTREE快，所以MEMORY引擎也更快)</li>
</ul>
<h3 id="B树-和-B-树"><a href="#B树-和-B-树" class="headerlink" title="B树 和 B+树"></a>B树 和 B+树</h3><p>数据结构演示网址：<a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html">https://www.cs.usfca.edu/~galles/visualization/Algorithms.html</a></p>
<h4 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h4><ul>
<li>定义：</li>
</ul>
<h4 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h4><ul>
<li>定义：</li>
</ul>
<h1 id="MySQL-事务"><a href="#MySQL-事务" class="headerlink" title="MySQL 事务"></a>MySQL 事务</h1><h2 id="一、事务"><a href="#一、事务" class="headerlink" title="一、事务"></a>一、事务</h2><ul>
<li><p>事务主要处理操作量大、复杂度高、并且关联性强的数据。</p>
</li>
<li><p>进行一系列相互关联的操作：删除用户—&gt;删除该用户相关所有的表数据。</p>
</li>
<li><p>在MySQL中只有InnoDB存储引擎支持事务。</p>
</li>
<li><p>事务处理可以用来维护数据库的数据完整性，保证成批的SQL语句要么不执行，要么都执行成功。</p>
</li>
</ul>
<h2 id="二、事物的四大特性"><a href="#二、事物的四大特性" class="headerlink" title="二、事物的四大特性"></a>二、事物的四大特性</h2><p>在写入或更新数据的过程中，为保证事务的正确可靠，必需具备四个特性（ACID）：</p>
<ol>
<li><p><strong>原子性</strong>（Atomicity）</p>
<ul>
<li>事务中的所有操作，要么全部完成，要么全部不执行，不会结束在中间某个环节；</li>
<li>事务在执行过程中发生错误，会被<strong>回滚（Rollback）</strong>到事务开始时前的状态，执行完成会有提交操作；</li>
</ul>
</li>
<li><p><strong>一致性</strong>（Consistency）</p>
<p>​        事务开始前和事务结束后，数据库的完整性不能被破坏，写入的数据完全符合数据库的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。</p>
</li>
<li><p><strong>隔离性</strong>（Isolation）</p>
<p>​        事务并发会相互影响，多个事务同时操作同一个数据时可能会出现的问题：</p>
<ul>
<li><strong>脏读</strong>：事务A修改了一个数据，但未提交，<strong>事务B读到了事务A未提交的更新结果</strong>，如果事务A提交失败，事务B读到的就是脏数据。</li>
<li><strong>不可重复读</strong>：在同一个事务中，对于同一个数据读取的结果不一致。比如，<strong>事务B在事务A提交前后读取到的内容不一致</strong>，导致的原因就是并发修改记录。想要避免这种情况，就要<strong>对修改的记录进行加锁</strong>，但这会导致锁竞争加剧，影响性能。另一种方式是通过<strong>MVCC（多版本的并发控制）</strong>可以在无锁的情况下避免不可重复读。</li>
<li><strong>幻读</strong>：在同一个事务中，同一个查询多次返回的结果不一致。事务A新增了一条记录，事务B在事务A提交前后各执行了一次查询操作，发现后一次比前一次多了一条记录。幻读是由于并发事务增加记录导致的，这个不能像不可重复读通过记录加锁解决，因为对于新增的记录根本无法加锁。需要将事务串行化，才能避免幻读。</li>
</ul>
<p>事务的隔离级别从低到高：</p>
<ol>
<li><strong>读取未提交 (Read uncommitted)</strong><ul>
<li>所有事物都可以看到其他未提交事务的执行结果</li>
<li>性能不好</li>
<li>会引发<strong>脏读</strong>：读取到未提交的数据</li>
</ul>
</li>
<li><strong>读提交 (read committed)</strong><ul>
<li>大多数数据库的默认隔离级别（MySQL除外）</li>
<li>满足了隔离：只能看见已提交事务的改变</li>
<li>会引发<strong>不可重复读</strong>：事务执行过程中数据可能会被其他事务修改并提交</li>
</ul>
</li>
<li><strong>可重复读 (repeatable read)</strong><ul>
<li><strong>MySQL的默认隔离级别</strong></li>
<li>同一事务的多个实例在并发读取数据时，会看到同样的数据行</li>
<li>会引发<strong>幻读</strong>：多事务同时操作会导致多次读取不一致</li>
<li>InnoDB 通过多版本并发控制 (MVCC，Multiversion Concurrency Control) 机制解决幻读问题；</li>
<li>InnoDB 还通过间隙锁解决幻读问题</li>
</ul>
</li>
<li><strong>串行化 (Serializable)</strong><ul>
<li>这是最高的隔离级别</li>
<li>它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之,它是在每个读的数据行上加上共享锁。MySQL锁总结</li>
<li>在这个级别，可能导致大量的超时现象和锁竞争</li>
</ul>
</li>
</ol>
</li>
<li><p><strong>持久性</strong>（Durability）</p>
<p>事务处理结束后, 对数据的修改就是永久的, 即便系统故障也不会丢失。</p>
</li>
</ol>
<h2 id="三、语法和使用"><a href="#三、语法和使用" class="headerlink" title="三、语法和使用"></a>三、语法和使用</h2><ul>
<li><p>开启事务: <code>BEGIN</code>或<code>START TRANSACTION</code></p>
</li>
<li><p>提交事务: <code>COMMIT</code>, 提交会让所有修改生效</p>
</li>
<li><p>回滚: <code>ROLLBACK</code>, 撤销正在进行的所有未提交的修改</p>
</li>
<li><p>创建保存点: <code>SAVEPOINT identifier</code></p>
</li>
<li><p>删除保存点: <code>RELEASE SAVEPOINT identifier</code></p>
</li>
<li><p>把事务回滚到保存点: <code>ROLLBACK TO identifier</code></p>
</li>
<li><p>查询事务的隔离级别: <code>show variables like &#39;%isolation%&#39;;</code></p>
</li>
<li><p>设置事务的隔离级别: <code>SET [SESSION | GLOBAL] TRANSACTION ISOLATION LEVEL &#123;READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE&#125;</code></p>
<p>InnoDB 提供的隔离级别有</p>
<ul>
<li><p><code>READ UNCOMMITTED</code></p>
</li>
<li><p><code>READ COMMITTED</code></p>
</li>
<li><p><code>REPEATABLE READ</code></p>
</li>
<li><p><code>SERIALIZABLE</code></p>
</li>
</ul>
</li>
</ul>
<h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="string">`abc`</span> (</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">int</span> <span class="keyword">unsigned</span> primary <span class="keyword">key</span> auto_increment,</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">unique</span>,</span><br><span class="line">    age <span class="built_in">int</span> <span class="keyword">unsigned</span></span><br><span class="line">) <span class="keyword">charset</span>=utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> abc (<span class="keyword">name</span>, age) <span class="keyword">values</span> (<span class="string">&#x27;aa&#x27;</span>, <span class="number">11</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> abc (<span class="keyword">name</span>, age) <span class="keyword">values</span> (<span class="string">&#x27;bb&#x27;</span>, <span class="number">22</span>);</span><br><span class="line"><span class="comment">-- 在事务中查看一下数据</span></span><br><span class="line"><span class="comment">-- 同时另开一个窗口，连接到 MySQL 查看一下数据是否一样</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> abc;</span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> abc (<span class="keyword">name</span>, age) <span class="keyword">values</span> (<span class="string">&#x27;cc&#x27;</span>, <span class="number">33</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> abc (<span class="keyword">name</span>, age) <span class="keyword">values</span> (<span class="string">&#x27;dd&#x27;</span>, <span class="number">44</span>);</span><br><span class="line"><span class="keyword">update</span> abc <span class="keyword">set</span> age=<span class="number">77</span> <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">&#x27;aa&#x27;</span>;</span><br><span class="line"><span class="comment">-- 在事务中查看一下数据</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> abc;</span><br><span class="line"><span class="keyword">rollback</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> abc;  <span class="comment">-- 事务结束后在查看一下数据</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
</search>
